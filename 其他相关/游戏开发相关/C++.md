* 块注释符（/*...*/）是不可以嵌套使用的。

  **#if 0 ... #endif** 属于条件编译，0 即为参数。

  此外，我们还可以使用 **#if 0 ... #endif** 来实现注释

* **现在才算理解声明和定义的区别了：**

  定义包含了声明，但是声明不包含定义，如

  ```c++
  int a = 0;     //定义并声明了变量 a
  extern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。
  ```

  函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。

  ```c
  void fun1();  //函数声明
  
  void fun1(){  //函数定义
      cout<<"fun1"<<endl;
  }
  
  ```

* 变量的类型间是可以互相转换的，转换又分为**自动转换和强制转换**。

  **自动转换规则：**

  - 1、若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
  - 2、转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。   a、若两种类型的字节数不同，转换成字节数高的类型   b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
  -  3、所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
  -  4、char型和short型参与运算时，必须先转换成int型。
  -  5、在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会**降低精度**:

  ```c++
  int a=1;
  double b=2.5;
  a=b;
  cout << a; //输出为 2，丢失小数部分
  int a = 1;
  double b = 2.1;
  cout << "a + b = " << a + b << endl;  //输出为a + b = 3.1
  ```

  **强制转换规则：**

  强制类型转换是通过**类型转换运算来实现的**。其一般形式为：（类型说明符）（表达式）其功能是把表达式的**运算结果强制转换成类型说明符所表示的类型**

  ```
  int a = 1;
  double b = 2.1;
  cout << "a + b = " << a + (int)b << endl;  //输出为a + b = 3
  ```

* C/C++ 编译 cpp 文件是**从上往下编译**，所以 main 函数里面调用其他函数时，如果其他函数在 main 函数的下面，则要在 main 函数上面**先声明这个函数**。

  或者把 main 函数放在最下面，这个不仅限于 main 函数，其他函数的调用都是如此。**被调用的函数要在调用的函数之前声明**。

* extern 关键字声明在变量和函数之前的说明。

  **1、作用在变量之前**

  变量**只允许定义一次**，但**可以在多个文件中声明**。

  Test.cpp 中：

  ```c++
  int s32Val = 0;     // 定义一个变量 s32Val，并赋初值为 0
  ```

  Test1.cpp 中：

  ```c++
  extern int s32Val;  // 声明变量 s32Val，它在 Test.cpp 中被定义，此处不可赋值
  ```

  Test2.cpp 中：

  ```c++
  extern int s32Val;  // 声明变量 s32Val,它在 Test.cpp 中被定义，此处不可赋值
  ```

  **2、作用在函数之前**

  Test.h：

  ```c++
  extern void Fun();   // 函数声明，extern 用于标识次函数为外部可调用函数
  ```

  Test.cpp：

  ```c++
  void Fun();  // 函数定义
  ```



## 内存管理

* 编译与链接

  * 编译：

    ![1_1_1.png](../../img/1661172766-jkudLd-1_1_1.png)

    * 定义：**将我们编写好的代码最终翻译为机器可执行的二进制指令**
    * 处理过程：编译器**读取源文件 `cpp`，并将其翻译为可执行文件**ELF，ELF 文件可以**经过操作系统进行加载执行**。
      * **编译预处理**：在预编译过程中主要**处理源代码中的预处理指令**，比如引入头文件（#include），去除注释，处理所有的**条件编译指令**（#ifdef, #ifndef, #else, #elif, #endif），**宏的替换**（#define），添加行号，保留所有的编译器指令；
      * **编译**：简单来说编译的过程即为**将 `.cpp` 源文件翻译成 `.s` 的汇编代码；**
      * **汇编**：**将汇编代码 `.s` 翻译成机器指令 `.o` 文件【目标文件】**，一个 `.cpp` 文件只会生成一个 `.o` 文件；
      * **链接**：汇编程序生成的**目标文件**即为 .o 文件，单独的 .o 文件可能无法执行。**因为一个程序可能由多个源文件组成，此时就存在多个 .o 文件。**文件 A 中的函数**引用**了另一个文件 B 中**定义的符号**或者调用了某个库文件中的函数，这就**需要链接处理**。那链接的目的就是**将这些文件对应的目标文件连接成一个整体，从而生成一个可被操作系统加载执行的 ELF 程序文件。**【可**链接动态(共享)库或静态库**】
      * **静态链接是由连接器完成的，动态链接最终是由操作系统来完成链接的功能**，动态链接在不同的操作系统下可能由不同的实现原理
        * 静态链接：
          * 代码在**生成可执行文件时**，**将该程序所需要的全部外部实现全部拷贝到最终的可执行程序文件中**，在该程序被执行时，该程序运行时**所需要的全部代码都会被装入到该进程的虚拟地址空间中。**
          * 缺点：**浪费空间，每个可执行程序都会有目标文件的一个副本**，这样如果目标文件进行了更新操作，就需要**重新进行编译链接生成可执行程序**（**更新困难**）
          * 优点：**执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容**。
        * 动态链接：
          * 代码在生成可执行文件时，该程序**所调用的部分程序被放到动态链接库中**，**链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息**，最**终生成的 ELF 文件中并不包含这些调用程序的机器指令。**在程序执行时，当**需要调用这部分程序时，操作系统会从将这些动态链接库中进行加载**，并将全部内容会被映射到该进行运行的虚拟地址的空间。
          * 缺点：**每次执行都需要链接，相比静态链接会有一定的性能损失。**
          * 优点：**节省内存、更新方便**
          * 注意：
            * 不同os的动态库实现不同，windows下不仅生产dll，还生成lib，其不是静态库，而是**导入库**，用于标识诸如函数实现在dll的位置等信息
            * win下动态库查找路径，本地程序目录-》系统Path路径，一般放到本地程序目录，测试时可将bin目录加到Path中
            * VS查找DLL路径【系统环境变量Path->用户环境变量Path】
            * 注意系统环境变量和用户环境变量相互独立，**为系统级别的配置使用系统环境变量**，并为用户级别的配置使用用户环境变量，以避免复杂的依赖关系和不必要的复杂性。
            * 库文件也需要经过编译生成，都是由`*.o`目标文件生成的。
        * 注意：
          * linux 静态库 .a，动态库为.so
  
  * C++程序内存分布：
  
    * ELF文件：
      * 定义：**可执行与可链接格式** (Executable and Linkable Format) 是一种用于可执行文件、目标代码、共享库和核心转储 （core dump） 的标准文件格式，**每个 ELF 文件都由一个 ELF header 和紧跟其后的文件数据部分组成**，可以参考ELF 文件的构成如下:![1_2_1.png](../../img/1661172875-aSnoQn-1_2_1.png)
      * 可执行程序内部是**分段存储的**
        * 只读段：
          * .text section：代码段。通常存放**已编译程序的机器代码**，一般操作系统加载后，这部分是只读的。
          * .rodata section：只读数据段。**此段的数据不可修改**，存放程序中会**使用的常量**。比如程序中的常量字符串 "aasdasdaaasdasd"。
        * 读写段：
          * .data section：数据段。主要用于存放**已初始化的全局变量、常量。**
          * .bss section: bss 段。该段主要存储**未初始化全局变量，仅是占位符，不占据任何实际磁盘空间。**目标文件格式区分初始化和非初始化是**为了空间效率。**
    * 操作系统在加载 ELF 文件时会将**按照标准依次读取每个段中的内容，并将其加载到内存中，同时为该进程分配空间**，并将 **pc 寄存器指向代码段的起始位置**，然后启动进程。
    * C++**程序**的内存分区：**按照不同的功能划分不同的段**，`C++` 程序使用的内存分区一般包括：**栈、堆、全局/静态存储区、常量存储区、代码区。**
      * **栈**：目前绝大部分 CPU 体系都是基于栈来运行程序，**栈中主要存放函数的局部变量、函数参数、返回地址等**，栈空间**一般由操作系统进行默认分配或者程序指定分配**，栈空间在进程生存周期一直都存在，**当进程退出时，操作系统才会对栈空间进行回收。**
      * **堆**：**动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放**，可以在程序运行周期内随时进行申请和释放，**如果进程结束后还没有释放，操作系统会自动回收**。
      * **全局区/静态存储区**：**主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，**在 C 中，**未初始化的放在 .bss 段中**，**初始化的放在 .data 段中，C++ 中不再区分了。**
      * **常量存储区**：.rodata 段，**存放的是常量**，不允许修改，程序运行结束自动释放。【**C风格字符串会在此处申请空间**，后续遇到同样字符串则同样在这个位置取出对应字符串的首字符地址返回】
      * **代码区**：.text 段，**存放源程序编译后的机器码**，不允许修改，但可以执行。**编译后的机器码存放在这里。**
    * 从操作系统的本身来讲，以上存储区在该程序内存中的虚拟地址分布是如下形式（**虚拟地址从低地址到高地址，实际的物理地址可能是随机的**）：![图片 1.jpg](../../img/1643371423-LnOKvn-图片 1.jpg)


* 堆与栈：

  * 运行时栈：
    * 定义：程序运行后对应的进程中用于表示函数调用的内存区域，与栈相符都是后进先出的特性，**函数调用过程需满足以下三大机制。**![image-20240126165542733](../../img/image-20240126165542733.png)
      * **传递控制**：调用某个函数时，会**将返回地址压入栈中**，当函数执行完成返回时，为程序计数器指明，**接着从哪个位置开始执行指令**，同时调用某个函数时，更新程序计数器为**要具体执行的指令位置**。【call指令实现整个传递控制的过程，返回地址一般为call指令后的那条指令的地址。】
      * **传递数据：**函数调用传递参数时，如果**调用过程需要的空间超出寄存器大小时**【通过寄存器最多传递6个整数值】，**才会在栈上分配空间即栈帧**，栈帧内**将会存储额外的局部变量**，**调用的返回值也会存储在寄存器中以便调用函数使用。**
      * **分配和释放空间**：CPU寄存器中记录着当前栈指针的位置，因为栈在进程空间中是向**低地址方向扩展**的，故在**栈上分配空间时将栈指针减少对应值，释放空间时栈指针增加对应值即可。
    * 栈溢出：一般情况**操作系统为每个进程会固定栈空间的大小**，也可以**根据自己的需要来分配每个进程的栈空间**，如果**剩余栈空间不够新的申请大小时，会分配失败导致栈溢出。**
    
  * 堆：
    * 定义：堆的内存空间一般**由操作系统或者专门内存程序来管理的**。在 C/C++ 一般用 malloc 或者 new 来从堆中申请内存，使用 free 或者 delete 来释放空间，空间释放后会有操作系统进行回收。
  
  * 栈和堆的对比：
    * **申请方式**：
      * **堆中存放的变量由程序运行时决定的，会有操作系统或者内存管理模块来进行分配的。**
      * 栈中存放的变量**在编译时由编译器为其在栈上分配了空间**，即**程序编译后该变量在栈中使用的内存即确定**，释放时也由于函数调用的返回，**栈的空间会自动进行回收。**
  
    * **申请后系统响应**：
      * 分配栈空间时如果**剩余空间大于申请空间则分配成功**，否则分配失败栈溢出，绝大多数情况下，栈的空间较小，一般栈上分配的变量不会占用太大的空间，且**当函数返回时，当前栈帧中的变量生存周期会结束；**
      * 申请堆空间，**堆在内存中呈现的方式类似于链表**（记录**空闲地址空间的链表**），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，堆上可以分配较大的空间，**如果不对申请的内存进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出。**
  
    * **安全性**：
      * 栈在内存中是**连续的**一块空间（**向低地址扩展**）**最大容量是系统预定好的，且只能被当前的线程访问；**
      * 堆在内存中的空间（**向高地址扩展**）**是不连续的**，中间允许有间隔，**堆中的内存并不是线程安全的，同一进程的线程都都可访问。**
  
    * **申请效率：**
      * 栈是由**系统自动分配，申请效率高**，但程序员无法控制；堆是**由程序员主动申请，效率低**，**使用起来方便但是容易产生内存碎片。**
  
    * **存放内容**：
      * **栈中存放的是局部变量、函数的参数、返回地址等**；**堆**中**存放的内容由程序员控制**。
  
* 变量定义与生存周期

  * **作用域与生命周期**，这两个属性代表**从时间和空间**两个不同的维度来描述一个变量。
  * 作用域：一个变量可以**被引用的范围**，常见的作用域可分为 6 种：**全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。**
    * **全局变量**：具有**全局作用域**。**全局变量只需在一个源文件中定义**，就可以作用于所有的源文件。**其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量以进行引用**。
    * **静态全局变量**：具有**文件作用域**。它与全局变量的区别在于如果程序包含多个文件的话，**它作用于定义它的文件里，不能作用到其它文件里**，即被 static 关键字修饰过的变量具有文件作用域。这样**即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。**
    * **局部变量**：具有**局部作用域**。它是自动对象（auto），在程序运行期间不是一直存在，而是**只在函数执行期间存在**，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回，局部变量对于函数外部的程序来说是不可见的。当然内部实际更复杂**，实际是以 {} 为作用域的。**
    * **静态局部变量**：具有**局部作用域。它只被初始化一次**，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于**全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见**，**只有定义该变量的函数内部可以使用访问和修改该变量。**
  
  * 生命周期：该变量**可以被引用的时间段**（生存期表示变量存在的时间）。
    * **全局变量:**  全局变量在整个程序运行期间都会一直存在，都可以随时访问，当程序结束时，对应的变量则会自动销毁，内存会被系统回收。
    * **局部变量**: 局部变量的生命周期仅限于函数被调用期间，当函数调用结束时，该变量会自动销毁。
    * **静态局部变量**：实际上静态局部变量的作用域仅限于函数内部，它的作用域与局部变量相同，但**实际上该变量在程序运行期间是一直存在的，生命周期贯穿于整个程序运行期间。**局部静态变量只能被初始化一次。

  * 存储位置：
    * **静态变量和全局变量存储于全局存储区。**
    * **局部非静态变量存储于栈区或堆区。**

  * 注意：
    * **全局变量定义在不要在头文件中定义**：如果在头文件中定义全局变量，**当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错**，因此不能再头文件中定义全局变量。**一般情况下我们将变量的定义放在 .cpp 文件中，一般在 .h 文件使用extern 对变量进行声明。**
  
* 内存对齐：

  * 定义：编译器**将程序中的每个 `数据单元` 的地址安排为机器字的整数倍。**

  * 原因：由于 `CPU` 的访问内存的特性决定，`CPU` 访问内存时**并不是以字节为单位来读取内存**，而是**以机器字长为单位**，内存对齐的主要目的是为了**减少 `CPU` 访问内存的次数，加大 `CPU` 访问内存的吞吐量。**

  * 内存对齐规则：

    * [C/C++内存对齐详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/30007037)![image-20220824131236539](../../img/image-20220824131236539.png)

    ![image-20220906165239342](../../img/image-20220906165239342.png)

    ![image-20220906165339974](../../img/image-20220906165339974.png)

  * **对齐系数**：**不同编译器有不同默认值，预编译命令#pragma pack(n)可对其改变。**

  * **有效对齐值**：**对齐系数和结构体中最长数据类型长度中较小的那个。**

    * (1) 结构体**第一个成员**的**偏移量（offset）**为0，以后**每个成员相对于结构体首地址的** offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。
  
    * (3) **结构体的总大小**为 **有效对齐值** 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。
  
  * c++11以后引入两个关键字 [alignas (opens new window)](https://zh.cppreference.com/w/cpp/language/alignas)与 [alignof (opens new window)](https://zh.cppreference.com/w/cpp/language/alignof)。其中`alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。【对齐方式即**有效对齐值**，**若小于\#pragma pack(n)则失效**，其值在不同编译器有不同值，默认为4】
  
  * 注意如果有**虚函数，别忘了虚指针。**
  
* 大端和小端

  * 字节序：**字节序列的排列方式**。

    不同 `CPU` 可能采用不同标准的字节序，所以**均按照网络标准转化成相应的字节序。**

    * 小端序：**将低序字节存储在起始地址（低位编址）**。**对于机器计算来说更友好和自然。![1_6_1.png](../../img/1661173350-WbnRmC-1_6_1.png)**
    * 大端序：**将高序字节存储在起始地址（高位编址）**，内存顺序和数字的书写顺序是一致的，对于人的直观思维比较容易理解，**网络字节序统一规定采用 `Big-Endian`。**![1_6_2.png](../../img/1661173365-PPzbSl-1_6_2.png)
  
  * 检测字节序：
  
    直接调用宏定义 `__BYTE_ORDER` 即可，可以通过引用 `<bits/endian.h>` 即可。
  
    ```c++
    bool byteorder_check() {
        int a = 1;
        return (*(char *)&a); /* 1 为小端机，0 为大端机 */
    }
    ```
  
  * 字节序转换：
  
    **将高位与低位依次进行交换即可完成**
  
* 内存泄漏[一般是**对于动态分配的堆内存**来说]：

  * 定义：指**程序在运行过程中**，由于疏忽或错误而**失去了对该内存的控制，从而造成了内存的浪费。**【**堆是动态分配的**，**一旦用户申请了内存分配而未及时释放**，那么**该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存。**】

  * 导致的问题：

    由于**内存未得到及时释放**，从而可能导致**可使用的动态内存空间会越来越少**，一旦**内存空间全部使用完**，则**程序可能会导致因为内存不够中止运行。**

  * 对于实际的程序来说，我们在调用过程中使用 malloc、calloc、realloc、new 等分配内存时，**使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。**

  * 内存泄漏的检测：

    * 一般都是**利用各种内存检测工具来检测内存泄漏**，当然关键还是**在于统计和分析申请和释放的相关日志。**
    * 内存检测工具：valgrind
  
  * 如何防止内存泄漏：
  
    * **内部封装**：**将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。**【避免出现内存重复释放问题应使用深拷贝，生命周期结束后会调用析构】
    * **智能指针**：智能指针是 `C++` 中**已经对内存泄漏封装好了一个工具**，智能指针对象**会自动释放所申请的内存**。【一种类似指针的类对象】
    * **良好的编码习惯：**
      * 在 `C++` 中需要**将基类的析构函数定义为虚函数**；
      * 遵循 RAII（Resource acquisition is initialization）原则：**在对象构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源；**
      * 尽量**使用智能指针**；
      * 有效**引入内存检测工具**；
  
* 智能指针：

  * 出现背景：**为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的**。`<memory>` 头文件中。【正确地管理动态内存非常困难】

  * 定义：smart pointer 遵循 RAII 原则，**当 smart pointer 对象创建时，即为该指针分配了相应的内存，当对象销毁时，析构函数会自动释放内存。**需要注意的是，**智能指针不能像普通指针那样支持加减运算。**【**区别于普通指针**的是它**会自动释放所申请的内存资源**。无需手动释放】

  * 简单实现：**栈比堆要安全的多，因为栈上的变量离开作用域后，会自动销毁并清理。智能指针结合了栈上变量的安全性和堆上变量的灵活性。**

    ```c++
    #include <iostream>
    using namespace std;
    
    template <class T>
    class SmartPtr {
    	T* ptr; // Actual pointer
    public:
    	explicit SmartPtr(T* p = NULL) { ptr = p; }
    	~SmartPtr() { delete (ptr); }
    	T& operator*() { return *ptr; }
    	T* operator->() { return ptr; }
    };
    
    int main()
    {
    	SmartPtr<int> ptr(new int());
    	*ptr = 20;
    	cout << *ptr;
    	return 0;
    }
    ```

  * 智能指针分类：

  * https://zhuanlan.zhihu.com/p/150555165

    https://yuanlehome.github.io/DVejmy5owOXx5WKk/ todo源码
    
    * **unique_ptr**：**独享所有权的智能指针**，**内部资源只能被一个指针占有，该指针不能拷贝构造和拷贝赋值。但可以进行移动构造和移动赋值（调用 move() 函数），移动语义表示资源所有权的移动**，即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。![1_9_1.png](../../img/1661173525-UZwbot-1_9_1.png)
      如图所示，`object` 资源只能被 `P1` 占有，`P2` 无法对 `object` 有所有权，**只能通过移动构造和移动赋值**给 `P2`。![image-20230227224734893](../../img/image-20230227224734893.png)
    
      ```c++
      #include <iostream>
      using namespace std;
      #include <memory>
      
      class Rectangle {
      	int length;
      	int breadth;
      
      public:
      	Rectangle(int l, int b){
      		length = l;
      		breadth = b;
      	}
      
      	int area(){
      		return length * breadth;
      	}
      };
      
      int main(){
      	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
      	cout << P1->area() << endl; // This'll print 50
      
      	unique_ptr<Rectangle> P2;
      	// unique_ptr<Rectangle> P2(P1); // 无法拷贝构造
      	// P2 = P1;   // 无法赋值构造
      	P2 = move(P1);
      
      	cout << P2->area() << endl;
      	
      	// cout<<P1->area()<<endl; // 已经传递，P1 无所有权
      	return 0;
      }
      ```

    * **shared_ptr**：与 unique_ptr 不同的是，**shared_ptr 中持有的资源可以被多个指针共享，但是多个指针指向同一个资源不能被释放多次，因此使用计数机制表明资源被几个指针共享。**![1_9_2.png](../../img/1661173547-qRsDoz-1_9_2.png)
    
      `shared_ptr` 并不是线程安全的，**但 `shared_ptr` 的计数是原子操作实现的，利用 `atmoic CAS` 指令实现**
      
      具体实现：**共享指针类中含有两个指针，一个指向具体的共享资源对象，另一个指向整型对象表明资源被几个指针共享**，共享指针对象**生命周期结束后【离开作用域后】引用技术减一**，如果**引用计数为0则通过给定的删除器进行资源的释放**，默认是通过delete释放。
      
      构成函数和析构函数都会调用相应修改引用计数的方法进行维护。![img](../../img/v2-d7c699721b3e4913623dc345f3169a57_720w.jpeg)![image-20230227224933678](../../img/image-20230227224933678.png)
      
      * 缺陷：
      
        * 出现**循环引用**情况时，可能出现**内存泄漏**情况。
      
          ```c++
          #include <iostream>
          #include <memory> // for std::shared_ptr
          #include <string>
          
          class Person
          {
          	std::string m_name;
          	std::shared_ptr<Person> m_partner; // initially created empty
          
          public:
          
          	Person(const std::string &name): m_name(name)
          	{
          		std::cout << m_name << " created\n";
          	}
          	~Person()
          	{
          		std::cout << m_name << " destroyed\n";
          	}
          
          	friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2)
          	{
          		if (!p1 || !p2)
          			return false;
          
          		p1->m_partner = p2;
          		p2->m_partner = p1;
          
          		std::cout << p1->m_name << " is now partnered with " << p2->m_name << '\n';
          
          		return true;
          	}
          };
          
          int main()
          {
          	auto lucy { std::make_shared<Person>("Lucy") }; // create a Person named "Lucy"
          	auto ricky { std::make_shared<Person>("Ricky") }; // create a Person named "Ricky"
          
          	partnerUp(lucy, ricky); // Make "Lucy" point to "Ricky" and vice-versa
          	
              // lucy变量 外引用lucy 内m_partener引用ricky 
              // ricky变量 外引用ricky 内m_partener引用lucy 
              // 此时两智能指针变量引用变量都为2
          	return 0;
          }// 离开作用域后 堆上两资源对象都无法析构 此时两智能指针变量引用变量都为1
          ```
      
    * **std::weak_ptr：**
    
      * weak_ptr被设计用来**解决shared_ptr的循环引用问题**。**相当于共享指针所引用资源的观察者，不是资源的所有者**【即**不会计数**】，但是它可以**通过`lock()`方法返回一个`std::shared_ptr`对象，从而访问这块资源**。
    
      * 解决循环引用问题：
    
        ```c++
        #include <iostream>
        #include <memory> // for std::shared_ptr and std::weak_ptr
        #include <string>
        
        class Person
        {
        	std::string m_name;
        	std::weak_ptr<Person> m_partner; // note: This is now a std::weak_ptr
        
        public:
        
        	Person(const std::string &name) : m_name(name)
        	{
        		std::cout << m_name << " created\n";
        	}
        	~Person()
        	{
        		std::cout << m_name << " destroyed\n";
        	}
        
        	friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2)
        	{
        		if (!p1 || !p2)
        			return false;
        
        		p1->m_partner = p2;
        		p2->m_partner = p1;
        
        		std::cout << p1->m_name << " is now partnered with " << p2->m_name << "\'\n';
        
        		return true;
        	}
        
        	const std::shared_ptr<Person> getPartner() const { return m_partner.lock(); } // use lock() to convert weak_ptr to shared_ptr
        	const std::string& getName() const { return m_name; }
        };
        
        int main()
        {
        	auto lucy { std::make_shared<Person>("Lucy") };
        	auto ricky { std::make_shared<Person>("Ricky") };
        
        	partnerUp(lucy, ricky);
        
        	auto partner = ricky->getPartner(); // get shared_ptr to Ricky's partner
        	std::cout << ricky->getName() << "'s partner is: " << partner->getName() << '\n';
        
        	return 0;
        }
        ```
    
      * 缺陷：
    
        * 当weak_ptr**所观察的资源已被释放时**，**其成为悬挂指针**，使用它时**将产生未定义行为**。

* C++的构造函数，拷贝赋值函数，和析构函数。什么是深复制和浅复制，构造函数和析构函数哪个能写成虚函数，为什么。

  * 构造函数：

    * 默认构造函数：可以**不用实参进行调用**的构造函数。**合成**默认构造函数：**编译器**自动分配的默认构造函数。自定义构造函数：自己定义的构造函数。

    * 在构造函数中使用**类初始化列表**，会**减少调用构造函数产生的开销**，原因：对于**非内置类型**【如string,容器等】，**少了一次调用默认构造函数和拷贝赋值函数的过程**。【创建临时对象时会调用成员变量默认构造函数进行初始化，且使用临时对象赋值时会调用拷贝赋值函数。】

      【C++ 规定，**对象的成员变量的初始化动作发生在进入构造函数本体之前**，**成员变量的初始化通过初始化列表来完成**，**默认的初始化列表为默认构造函数**】

  * **构造函数不能定义为虚函数**：**构造函数是在创建对象时调用的**，因为**虚表指针需创建对象后才能获得**，故如果将构造函数定义为虚函数，那么就无法通过虚表指针获取虚构造函数指针进行调用完成对象的创建了。

  * **析构函数一般定义为虚函数**：析构函数定义成虚函数是为了**防止内存泄漏**，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果**未将基类的析构函数定义成虚函数**，delete该指针时会调用基类的析构函数，那么**只能将基类的成员所占的空间释放掉**，**派生类中特有的就会无法释放内存空间导致内存泄漏**。故需将析构函数定义为虚函数，以便**delete时先调用派生类的析构函数再自动【编译器默认行为，避免内存泄漏】调用基类析构函数。**

  * **拷贝赋值函数**：赋值运算符重载实现，没自定义拷贝赋值函数，编译器会自动分配，其实质是一个bit一个bit的拷贝，拷贝构造也是类似的。

    可以通过**弃置函数delete和private继承来避免对象拷贝**：

    ```c++
    class noncopyable {
    protected:
        noncopyable() = default;
        ~noncopyable() = default;
    public:
        noncopyable(const noncopyable&) = delete;
        // 有返回值的原因是为了支持链式赋值 a = (b = c);
        // 返回类型为引用的原因是为了运行效率，减少拷贝带来的开销
        noncopyable& operator=(const noncopyable&) = delete;
    };
    
    class foo : private noncopyable { 
    };
    ```
    
  
* C++ String类的简单实现【封装一个char*持有字符串数据】

```c++
#include <iostream>
#include <cstring>

class String {
private:
    char *data;

public:
    // 默认构造函数
    String() : data(nullptr) {}

    // 构造函数
    String(const char *str = NULL) {
        if (str) {
            // 避免重复释放
            data = new char[std::strlen(str) + 1];
            // 用于将C风格字符串复制
            std::strcpy(data, str);
        } else {
            data = nullptr;
        }
    }

    // 拷贝构造函数
    String(const String &other) {
        if (other.data) {
            data = new char[std::strlen(other.data) + 1];
            std::strcpy(data, other.data);
        } else {
            data = nullptr;
        }
    }

    // 析构函数
    ~String() {
        delete[] data; // 释放数组
    }

    // 赋值运算符重载
    String& operator=(const String &other) {
        if (this != &other) {
            delete[] data; // 先清理原先的数据
            if (other.data) {
                data = new char[std::strlen(other.data) + 1];
                std::strcpy(data, other.data);
            } else {
                data = nullptr;
            }
        }
        return *this;
    }

    // 获取字符串长度
    std::size_t length() const {
        return data ? std::strlen(data) : 0;
    }

    // 获取字符串内容
    const char* c_str() const {
        return data ? data : "";
    }

    // 追加字符串
    void append(const char *str) {
        if (str) {
            std::size_t len1 = length();
            std::size_t len2 = std::strlen(str);
            char *temp = new char[len1 + len2 + 1];
            std::strcpy(temp, data);
            std::strcpy(temp + len1, str);
            delete[] data;
            data = temp;
        }
    }
};

int main() {
    // 使用示例
    String s1("Hello");
    String s2 = s1;  // 调用拷贝构造函数
    String s3;
    s3 = s1;         // 调用赋值运算符重载

    std::cout << "s1: " << s1.c_str() << std::endl;
    std::cout << "s2: " << s2.c_str() << std::endl;
    std::cout << "s3: " << s3.c_str() << std::endl;

    s3.append(" World!");
    std::cout << "After appending: " << s3.c_str() << std::endl;

    return 0;
}

```




* **虚函数和虚表的原理是什么（重点）**

  https://blog.twofei.com/496/

  https://zhuanlan.zhihu.com/p/410786957

  * 虚函数表：即函数指针数组，数组元素为指向各虚函数的指针。

  * 虚表指针：**指向虚函数表的指针**，存在于**含有虚函数的类对象的内存空间中**【位置一般最靠前】。

  * **同一个类的不同实例共用同一份虚函数表**，故虚表指针也相同。

  * 类对应的**虚函数表在编译期就创建好**，只存在一份。**定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表。**

  * 父类指针指向子类对象时，会自动计算父类在子类内存布局中的偏移并进行转换，**使得指针指向子类中父类部分的起始地址**。

  * 派生类对象的内存布局中靠前的为父类对象数据，多继承时按声明顺序【含有虚指针的父类靠前】，虚函数覆盖后，子类内存布局中相应父类的虚表会进行替换，且子类内存布局中一定保证虚指针在首位，无论是父类数据虚指针还是自己的。如果父类有虚指针，子类定义虚函数，则虚指针对应的虚表会添加子类定义的虚函数指针，否则，外部定义一个子类自己的虚指针。【子类定义单独的虚函数**其地址存储在第一个有定义的虚函数父类对应的虚表的后面**，且子类内存布局中有虚函数的父类位置靠前，只有父类都没虚函数时，子类才会有虚指针】

  * **只有通过指针进行虚函数调用才会发生动态绑定**，因为指针**无法知道指向的对象是哪个派生类**，其需要**获取指针类型对应的虚指针**【地址就是指针的地址】然后**再调用该虚表对应的方法**。【多继承的情况下会**先定位到指向虚函数对应的虚表的虚指针**，如下反汇编所示。】

  * ```c++
    
    class Base1
    {
    public:
        int base1_1;
        int base1_2;
    
        virtual void base1_fun1() { cout << "Base1 base1_fun1" << endl; }
        virtual void base1_fun2() { cout << "Base1 base1_fun2" << endl; }
    };
    
    class Base2
    {
    public:
        int base2_1;
        int base2_2;
    
        virtual void base2_fun1() { cout << "Base2 base2_fun1" << endl; }
        virtual void base2_fun2() { cout << "Base2 base2_fun2" << endl; }
    };
    
    // 多继承
    class Derive1 : public Base1, public Base2
    {
    public:
        int derive1_1;
        int derive1_2;
    
        // 基类虚函数覆盖
        virtual void base1_fun1() { cout << "Derive1 base1_fun1" << endl; }
        virtual void base2_fun2() { cout << "Derive1 base2_fun2" << endl; }
    
        // 自身定义的虚函数
        virtual void derive1_fun1() { cout << "Derive1 base1_fun2" << endl; }
        virtual void derive1_fun2() { cout << "Derive1 derive1_fun2" << endl; }
    };
    
    void testVptr() {
        // 转化为Derive1中Base2部分的起始地址
        Base2* base2 = new Derive1();
        // 无法通过编译 Base2中没有定义
        //base2->base1_fun1();
        //base2->derive1_fun1();
        //base2->derive1_fun2();
        
        // 使用Base2部分的虚表【base2_fun2虚函数被Derive1的同名函数覆盖了】
        base2->base2_fun1();
        base2->base2_fun2();
    
        Derive1* derive1 = new Derive1();
        derive1->base1_fun1();
        derive1->base2_fun2();
        // 反汇编情况如下：
            00DA2605  mov         ecx, dword ptr[derive1]
            00DA2608  add         ecx, 0Ch
            00DA260B  mov         eax, dword ptr[derive1]
            00DA260E  mov         edx, dword ptr[eax + 0Ch] // 用的虚指针是Base2的
            00DA2611  mov         esi, esp
            00DA2613  mov         eax, dword ptr[edx + 4] 
            00DA2616  call        eax
            00DA2618  cmp         esi, esp
            00DA261A  call        __RTC_CheckEsp(0D9179Eh)
        derive1->derive1_fun1();
        derive1->derive1_fun2();
    }
    ```

  * 对于**空类**，只会生成 **1 个字节的占位符【为了实例化后标识每个对象，编译器会给空类添加一个字节，保证实例化后每个对象都有独一无二的地址】**，编译器默认会为其生成6个成员函数，**缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。**【“只有当一个类的**所有数据成员都能移动构造或移动赋值时**，编译器**才会为它合成移动构造函数或移动赋值运算符**。”】

    ```c++
    /*
    class A
    {}; 该空类的等价写法如下：
    */
    class A
    {	
        // 对于非基本数据类型才需考虑移动构造，因为对于基本数据类型其移动构造等价于拷贝构造
    	std::string s1, s2;
    public:
    	A() {};                                       // 缺省构造函数
    	A(const A& tmp):s1(tmp.s1),s2(tmp.s2) {};      // 拷贝构造函数
    	~A() {};                                      // 析构函数
    	A& operator=(const A& tmp) { s1 = tmp.s1; s2 = tmp.s2; };  // 拷贝赋值运算符
    	A* operator&() { return this; };             // 取址运算符
    	const A* operator&() const { return this; }; // 取址运算符（const 版本）
    	A(const A&& tmp):s1(std::move(tmp.s1)),s2(std::move(tmp.s2)) {}; // 移动构造
    	A& operator=(const A&& tmp) { s1 = std::move(tmp.s1); s2 = std::move(tmp.s2); };//移动赋值
    };
    
    ```

  * 注意：

    * **默认构造**的构造操作：

      * **基类持有默认构造【按照声明顺序调用基类的默认构造】**

      * **类中成员对象持有默认构造【按照声明顺序调用成员类的默认构造】****

      * **持有虚函数的类【为对象生成虚表和插入虚指针，调用处转变成通过虚指针指向的虚表内的相应虚函数进行调用】**

      * **持有虚基类的类【为对象插入指向虚基类对象的指针，并在调用虚基类成员处进行相应转变】**

      * 只有上面四种情况**，编译器才会为**未显式声明construct**的类合成default construct【如果**已显示声明则编译时**会扩张**相关代码**】，对应的合成物被称为implicit **nontrivial** default constructors，这些构造器**只能满足编译器【非程序】**的需要，主要**通过调用成员类和基类的默认构造或者为每个对象初始化其虚函数机制或者虚基类机制**来实现的。

        在合成的default constructor中，**只有基类和成员对象会按声明顺序初始化**，**其他的非静态成员数据则不会初始化，具体值视情况而定。**

        * **全局对象**的内存会在程序启动时被清为0，故**值为0**
        * **局部对象【栈上申请】和堆对象【自由空间堆上申请】**，都不一定会被清为0，故**值为内存上次被使用后的遗迹。**

      * 其余情况编译器合成的构造器为implicit **trivial【无用】** default constructors，并**不会做额外的操作**。

  * **拷贝构造函数**中的**形参必须为引用**，否则调用该函数时会出现**无限制的递归**，最终导致**栈溢出**。【如果不是引用类型，那么在调用的时候**因参数对象初始化**会**重新实例化一个对象**，但是实例化这个对象又需要调用拷贝构造函数，那么就**递归调用拷贝构造函数了**，**形参初始化时需要调用拷贝构造**】

  * **拷贝构造函数中参数是否为常量引用并没有要求**，不加const，编译器也不会报错。但是为了整个程序的安全，还是加上const，**防止对引用类型参数值的意外修改**。（提示这是一个输入参数）

  * 拷贝构造函数的使用位置：

    * 基于值传递的参数传递时【void fun(A a)】
    * 函数返回类型为非引用类型时【A fun(int val)】
    * 使用同一类型的变量定义变量时【A a2 = a1 或 A a2(a1) **有类型声明的时候，不管有没有等号都是构造**，之前**定义过用等号接收的就是赋值**。】




## C++11 新特性

* delete关键字：可作用于任何函数，**标识该函数不可使用即弃置**。

* emplace：就地构造**（直接在容器内构造对象，不用拷贝一个复制品再使用）**，相比与push减少了拷贝构造的过程

* lambda表达式：

  * 定义：**一个可调度的代码单元，可以视为一个未命名的内部函数**
  * lambda 函数是一个**仿函数对象**，编译器**在编译时会生成一个 lambda 对象的类**，然后**再生成一个该类未命名的对象**
  * lambda 的形式如下：
    [捕获列表] (参数列表) -> 返回类型 { 函数部分 }
    [capture list] (parameter list) -> return type { function body }
  * 捕获列表是 lambda 函数所定义的函数的**局部变量列表**， 通常为空
    * lambda表达式所在的函数中的局部变量必须被lambda捕获了才能在lambda表达式中使用。
    * 捕获列表**只用于局部非 static 变量**。 lambda 可以**直接使用局部 static 变量** 和在**它所在函数之外的声明的变量**。
    * 捕获列表的变量可以分为 **值 或 引用传递**
      * 值传递： lambda 捕获的**变量在 lambda 函数 创建 就发生了拷贝**而非调用时。

    * 隐式捕获：编译器可以根据 lambda 中的**函数体推导使用的变量，为编译器推断捕获列表**，应该在捕获列表中**写一个 & 或 =**
      & **告知编译器采用引用传递方式**
      = **告知编译器采用值传递方式**
      * 当混合使用时，捕获列表第一个参数必须是 & 或 = 且**显示捕获的变量必须和隐式捕获使用不同的传递方式**
      * 推荐 用 值捕获， 不要用 引用捕获。
        **引用捕获 容易外部被销毁**

  * 参数列表：参数列表和普通函数类似，但是 **lambda 不能有 默认参数**【lambda **实参和形参数目一定相等**】
  * 返回类型：
    * 与一般函数的返回类型为前置定义不同，lambda**必须使用尾置返回类型来定义返回类型**
    * 如果**忽略返回类型**，lambda 表达式会**根据函数体中的代码推断出返回类型**
    * 若函数体**只有一个 return 语句**， 则**返回类型从返回表达式的类型推断而来**，否则，**若未指定返回类型，返回类型为 void**

  * 函数体：与一般函数类似。![image.png](../../img/1626425366-IlqZyH-image.png)

* explict

  * 作用：用来**声明类单参构造函数是显示调用的**，而**非隐式调用**，可以**阻止调用构造函数时进行隐式转换**。【因为**无参构造函数和多参构造函数本身就是显示调用的**】

  * ```c++
    class A {
    private:
    	int m_i;
    public:
    	A(int a) : m_i(a)
    	{
    		cout << "A(int a) 调用" << endl;
    	}
    	A& operator= (const A& a)
    	{
    		cout << "operator= (const A& a) 调用" << endl;
    		this->m_i = a.m_i;
    		return *this;
    	}
    };
    
    int main()
    {
    	A ex = 10; // 相当于A ex(10) 没有赋值操作 发生隐式转换 
    	cout << "-------------------------------" << endl;
    	ex = 11; // 11隐式转换成A类型 再拷贝赋值
    }
    ```

* auto：

  * 作用：
    * 声明变量时**根据初始化表达式自动推断该变量的类型；**[使变量定义变得更简单]
    * 声明函数时**函数返回类型的占位符；**[C++14]
    * 注：无法使用auto作为形参类型声明
    
  * 类型推导规则：
    * 类似模板类型的推导规则。https://zhuanlan.zhihu.com/p/390608866
    * 1、如果初始表达式是引用，则去除引用，如果auto带上&则不去除。如果初始表达式不是引用，则去除顶层const和volatile。
    * 2、如果auto是universal reference则根据规则推到成左值引用或右值引用。【故也可实现完美转发】
  
  * 实现原理：
    * 通过**模板实参推断**的机制实现。**auto会被一个虚构的模板类型参数T代替**，然后进行推断，即相当于**把变量设为一个函数参数，将其传递给模板并推断模板实参**，**auto相当于利用了其中进行的实参推断，承担了模板参数T的作用**。
  
  * 注意：
    * **对初始化列表的推断，auto会将其视为std::initializer_list，而模板则不能对其推断**，故**不能在返回类型为auto的函数返回一个初始化列表**。【C++14还允许auto作为返回类型，但此时**auto仍然使用的是模板实参推断的机制**】

* function和bind的用法

  * 在C++11中，提供了std::function和std::bind两个方法来对**可回调对象进行统一和封装。**

  * C++语言中有**几种可调用对象【Callable类型】**：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。 

  * **可调用对象也有类型**。例如，每个lambda有它自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定。

  * std::function的用法【头文件#include< functional >中】

    * ```cpp
      #include <iostream>
      #include <functional>
      void printA(int a)
      {
              std::cout<<"a = "<<a<<std::endl;
      }
      class Foo{
      public:
              Foo(int num) : num_(num){}
              void print_add(int a) const
              {
                      std::cout<<num_+a<<std::endl;
              }
              int num_;
      };
      int main()
      {
              std::function<void(int a)> func;
              func=printA;
              func(22);
          	std::function<void()> func2=[](){std::cout<<"hello world"<<std::endl;};
              func2();
          	std::function<void(const Foo&,int)> test=&Foo::print_add;
              Foo foo(10);
              test(foo,1);
              return 0;
      }
      ```

  * ### **std::bind用法**

    * 可将bind函数看作是一个通用的函数适配器，它接受一个**可调用对象**，生成一个新的可调用对象来**“适应”原对象的参数列表。**

    * ```c++
      std::function<void(int,int)> fc = std::bind(&A::fun_3, a, std::placeholders::_1,std::placeholders::_2);
      // A::fun_3需要3个参数，第一个默认为a，第二三个实际调用fc时作为fc的第一二个参数传入
      ```

  * **range-based for循环**
  
    * C++11引入了range-based for循环，可以**方便地遍历容器中的元素。**这样可以**减少代码中的重复代码**，提高代码的可读性和可维护性。
  
  * **nullptr**
  
    * C++11引入了nullptr关键字，可**以代替NULL宏定义。这样可以避免一些潜在的错误**
  
  * ### constexpr
  
    * C++11引入了constexpr关键字，可以**在编译期间计算表达式的值。**这样可以提高代码的性能和效率。
  
  * **右值引用**
  
    * C++11引入了右值引用，可以方便地**实现移动语义和完美转发**。这样可以**提高代码的性能和效率**。
  
  * **static_assert**
  
    * C++11引入了static\_assert关键字，可以**在编译期间检查表达式的值是否为真。**这样可以避免一些潜在的错误。
  
    * ```c++
      static_assert(sizeof(int) == 4, "int must be 4 bytes"); // 如果sizeof(int)不等于4，编译会失败
      ```
  
  * **变长参数模板**
  
    * C++11引入了**变长参数模板**，可以**方便地处理可变数量的参数**。这样可以**提高代码的灵活性和可维护性**。
  
    * ```c++
      template<typename... Args>
      void f(Args... args) {
          std::cout << sizeof...(args) << std::endl; // 打印参数的数量
      }
      f(1, 2, 3); // 打印3
      f("hello", 3.14); // 打印2
      ```
  
      

## C++14

* Reader-writer locks

## C++17

* 并行算法

  * 从C++17开始。 algorithm 和 numeric 头文件的中的很多算法都添加了一个新的参数：`sequenced_policy`。

  * 借助这个参数，开发者可以**直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。**

  * `sequenced_policy`可能的取值有三种，它们的说明如下：

    | 变量                 | 类型                                   | C++版本 | 说明                                 |
    | -------------------- | -------------------------------------- | ------- | ------------------------------------ |
    | execution::seq       | execution::sequenced_policy            | C++17   | 要求并行算法的执行可以不并行化       |
    | execution::par       | execution::parallel_policy             | C++17   | 指示并行算法的执行可以并行化         |
    | execution::par_unseq | execution::parallel_unsequenced_policy | C++17   | 指示并行算法的执行可以并行化、向量化 |

## C++STL

* 除了stack和queue外，STL中的容器都有在指定位置插入元素的函数insert(iterator position, const valueType val)，**第一个参数是相应迭代器不是整型！！**，而string的insert的第一个参数可以是整型也可以是迭代器，且字符串的插入一般是用来插入字符串，如需插入字符则需迭代器。![image-20220907215737951](../../img/image-20220907215737951.png)

* STL六大部件：
  
  * 容器（Containers）
    * 定义： **各种数据结构**，如Vector,List,Deque,Set,Map,**用来存放数据，STL容器是一种Class Template**
  
  * 分配器（Allocators）
    * 定义：容器需要占用内存，**容器占用的内存由分配器分配与管理**；
    * 从实现的角度来看，分配器是一个**实现了动态空间配置、空间管理、空间释放的Class Template。**
  
  * 算法（Algorithms）
    * **被独立出来的模板函数，用来操作容器**，比如常见的排序算法、查找算法等；
  
  * 迭代器（Iterators）
    * 算法既然要**操作容器中的数据**，需要**有工具访问容器中数据**，那就是迭代器，是**一种泛化的指针**；
    * 从实现的角度来看，迭代器是一种将：Operators*,Operator->,Operator++,Operator--等相关操作予以重载的Class Template。所有STL容器都附带有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一种迭代器。
  
  * 适配器（Adapters）
    * 定义：一种用来修饰**容器（Containers）**或**仿函数（Functors）**或**迭代器（Iterators）**接口的东西，本质上，一个适配器是一种机制，能**使某种事物的行为看起来像另外一种事物一样。**
    * 分类：
      * Container Adapter
        * **接受一种已有的容器类型**，使其行为看起来**像一种不同**的类型。
        * 例如：STL提供的Queue和Stack，虽然看似容器，**其实只能算是一种容器配接器**，因为 它们的底**部完全借助Deque，所有操作有底层的Deque供应。**
  
      * Iterator Adapter
        * 改变Iterator接口
  
      * Function Adapter
        * 改变Functor接口
  
  * 仿函数（Functors）
    * 行为类似函数，可**作为算法的某种策略（Policy）**，从实现的角度来看，**仿函数是一种重载了Operator()的Class 或 Class Template。一般函数指针可视为狭义的仿函数。**
    * 如less和greater常用在排序容器set和map中
  
  * 六大部件之间的关联：![在这里插入图片描述](../../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpbmdPZk15SGVhcnQ=,size_16,color_FFFFFF,t_70.png)
  
* STL容器分类：

  * 基本介绍：

    * 1，array、vector、deque的**内存是连续的，连续的内存空间必定是支持随机访问的**，其余容器则不具备该特点。其中array为固定长度，vector、deque为变长，vector只能单向扩充，deque可以双向扩充。
    * 2，list、forward-list为**链条式结构**，这种结构在插入、删除时**只需要局部调整非常方便**。但是**遍历时只能按照链条顺序依次遍历，查找起来并不迅速**。
    * 3，set、map背后的实现为**红黑树**，基于关键字重载的小于操作符进行自动排序，所以对**查找具有先天的优势**，但这种结构**插入删除时会产生联动效应**，所以并**不适合做频繁的删除、插入。**其中各自**multi版本表示内容可以重复。**
    * 4，unordered_set、unordered_map背后实现为哈希表，对查找有很好的支持。其中各自**multi版本表示内容可以重复。**

  * 序列式容器 sequence containers：

    * array【c++11】

    * vector

      * 支持随机访问，动态数组，分配的内存空间是以2的倍数动态增长的，**空间扩展时涉及拷贝操作，性能开销较大。**

      * clear操作**只是把vector的size清为0**，但v**ector中的元素在内存中并没有消除，所以在使用vector的过程中会发现内存消耗会越来越多，导致内存泄露**，现在经常用的方法是swap函数来进行解决： 

        ```c++
        vector<int>().swap(V); 
        //或者 V.swap(vector<int>()); 和临时对象的内容进行交换，之后临时对象会被析构掉 临时对象的生命周期只有一条语句的时间
        ```

      * 为了避免空间扩展造成的开销，一般预估元素个数来提前申请空间。

      * 删除某个位置的元素，该位置后的所有迭代器都失效，因为**元素需前移**，可以将**待删除元素与尾元素交换再删除新尾元素即可**，将**不涉及元素的前移。**

    * deque

      * 类似vector，支持**随机访问**，vector只能在末端插入数据，而**deque支持双端**插入数据。

      * **分段连续**存储结构，deque 容器用数组（数组名假设为 map）存储着**各个连续空间的首地址**，即**数组中存储的是指针**，指向那些真正用来存储数据的各个连续空间。**重新分配空间不涉及元素的拷贝，只涉及指针的拷贝。**![deque容器的底层存储机制](../../img/2-191213161305R5.gif)

      * 随机访问迭代器的实现：
        * 迭代器移动时需根据**当前是否处于连续空间的边界来判断是否需跳跃到上一个或者下一个连续空间中。**
        * 故deque迭代器内部需包含4个指针：
          - cur：指向当前正在遍历的元素；
          - first：指向当前连续空间的**首地址**；
          - last：指向当前连续空间的**末尾地址**；
          - node：它是一个二级指针，**用于指向 map 数组中存储的指向当前连续空间的指针。**

      * 基于deque实现的适配器容器
        * stack：
        
        * queue：
        
          * priority_queue：默认**大顶堆**，第二根泛型参数为实现方式【其他容器less时优先级高的是放尾部，不像大顶堆放的是头部】
        
            ```c++
            // 小顶堆 小的优先级更高  >
            priority_queue <int,vector<int>,greater<int> > q;
            // 大顶堆 降序 默认的 大的优先级更高  <
            priority_queue <int,vector<int>,less<int>, decltype(less<int>)>q;
            ```
        
            

    * list

      * **双向链表**，故内存空间不连续，这使list的**随机存储变得非常低效**，因此list没有提供[]操作符的重载。但list可以很好地支持**任意地方的插入和删除**，只需移动相应的指针即可。

    * forward-list 【C++11】

      * 单链表，因此它们**只能向前迭代**。

  * 关联式容器 associative containers（红黑树实现）

    * 关联容器中的元素是按**关键字**来保存和访问的。

      * 红黑树：
        * 默认**升序排序**，里面的元素都是排序好的，支持**插入，删除，查找**等操作，操作时仅仅**移动指针即可**，**不涉及内存的移动和拷贝**。所有的操作的都是严格在**logn时间**之内完成，效率非常高。
        * **不允许修改关键字**，因为内部实现是**修改关键字后不会自动调整红黑树结构**，故**需先删除再插入关键字。**
        * 基于比较函数， 对于键类型，唯一的约束就是**必须支持 < 操作符**【两次<操作判断**是否关键字相等**，**一次进行排序**】

      * set
        * 元素唯一

      * multiset
        * 元素不唯一

      * map
        * 键值对形式，**以键作为关键字**

      * multimap

  * 无序容器 unordered containers （hash表实现）

    * 哈希表：通过**对键做哈希运算将键值对存储**，需要定义hash_value函数并且**重载operator==**。
      * 无论是查找效率还是插入、删除效率unordered_map都优于map
      * 负载因子[hashtable的元素个数与hashtable的桶数之间比值]大于等于最大负载因子时，进行rehash
        * rehash：
          * **扩容**，分配一块更大内存，来容纳更多的桶。
          * **重新插入**。按照上述插入步骤将原来桶中的buck_size个节点**重新插入到新的桶中**。

      * unordered_set【C++11】
      * unordered_multiset【C++11】
      * unordered_map【C++11】
      * unordered_multimap【C++11】
    
  * 其他容器：

    * string：

      * 是basic_string类模板对于char类型的**模板特化**

      * 没有split方法，我们可能需要手写

        ```c++
        vector<string> split(string& data, const char flag){
            vector<string> res;
            string temp = "";
            if(data.find(flag) != -1){
                for(const char c in data){
                    if(c == flag){
                        res.push_back(temp);
                        temp = "";
                    }else{
                        temp += c;
                    }
                }
                res.push_back(temp);
            }
            return res;
        }
        ```

      * string库中有一堆转换函数，便于我们编码![image-20230123153944798](../../img/image-20230123153944798.png)

        ```c++
        // 以指定基数base解析为整数【默认10进制解析】 如果 idx 不是空指针，该函数还将 idx 的值设置为 str 中数字后面第一个字符的位置。 
        int stoi (const string&  str, size_t* idx = 0, int base = 10);
        ```

* 迭代器：

  * 定义：

    * 一种抽象的设计概念，在设计模式中有迭代器模式，即提供一种方法，**使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式**。迭代器只是一种概念上的抽象，**具有迭代器通用功能和方法的对象**都可以叫做**迭代器**。
    * **迭代器也是泛化指针**。与智能指针类似，都是行为类似于指针的类。**只不过迭代器的主要工作为了访问容器元素，智能指针用于解决内存泄漏问题**
    * 增强for循环的实现原理即**使用C++11中的新特性，即“迭代器范围”，它允许程序员将迭代器范围传递给for语句，并使用迭代器对容器中的元素进行迭代，从而使循环更加简洁。**

  * 分类：迭代器基本分为五种，**输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。**

    * 输入迭代器(Input Iterator)：只能**向前单步迭代元素**，**不允许修改由该迭代器所引用的元素；**
    * 输出迭代器(Output Iterator)：只能**向前单步迭代元素**，**对由该迭代器所引用的元素只有写权限；**
    * 向前迭代器(Forward Iterator)：该迭代器可以**在一个区间中进行读写操作**，它**拥有输入迭代器的所有特性和输出迭代器的部分特性**，以及**向前单步迭代元素的能力**；
    * 双向迭代器(Bidirectional Iterator)：在**向前迭代器的基础上增加了向后单步迭代元素的能力；**
    * 随机访问迭代器(Random Access Iterator)：不**仅综合以后 4 种迭代器的所有功能**，**还可以像指针那样进行算术计算；**![image-20230315120804039](../../img/image-20230315120804039.png)
    * ![5_17_1.png](../../img/1661515579-ASMhMu-5_17_1.png)![image-20220916210502336](../../img/image-20220916210502336.png)

  * 常量迭代器和非常量迭代器类型![image-20220925221145131](../../img/image-20220925221145131.png)

    * **只能读或能读写**

  * 通用支持的运算符

    ![image-20220925220907163](../../img/image-20220925220907163.png)

    随机访问迭代器：![image-20220925221651056](../../img/image-20220925221651056.png)

    ![image-20230315121229973](../../img/image-20230315121229973.png)

  * 迭代器失效：

    * **向容器添加元素和从容器中删除元素的操作可能会使迭代器失效。**
    * 迭代器有有效和无效之分：
      * ![image-20220925220611183](../../img/image-20220925220611183.png)
    * 如何规避迭代器失效问题：
      * **保证每次改变容器的操作之后都正确地重新定位迭代器。**
        * insert和erase操作都会返回迭代器，使用返回值进行更新即可。[insert返回的迭代器指向新插入的元素，erase返回的是删除元素后的下一个元素的迭代器]

      * **不要保存end返回的迭代器。**
        * ![image-20220925223735401](../../img/image-20220925223735401.png)

    * 序列式容器的迭代器失效：
      * ![image-20220925222604364](../../img/image-20220925222604364.png)
    * 关联式容器迭代器失效
      * 对于关联容器(如map, set,multimap,multiset)，**删除当前的iterator，仅仅会使当前的iterator失效**，只要在erase时，递增当前iterator即可。
      * 使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响，**整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。**
      * erase迭代器**只是被删元素的迭代器失效**，但是返回值为void，所以要**采用erase(iter++)的方式删除迭代器**。

* 常见算法：

  * 

* 各容器常见的坑：

  * 常见容器添加元素时，都会调用**拷贝构造函数**

  * 通过键下标访问unordered_map时，如果**键不存在，则会插入键并使用默认构造函数初始化出对应的值**【值类型默认的初始值】，存在则返回引用。

  * 在插入元素前，如果vector容器元素个数达到2的n次方，**则会进行空间增长呈双倍形式**，其会**先把旧空间的元素通过拷贝构造拷贝进新空间，然后再将新元素插入新空间**，最后会把旧空间的旧元素析构掉。

  * 排序容器，需要写**内部比较器或外部比较器**

    ```c++
        // 内部比较器 
        // 其实插入数据其实要做两步。要调用三次 Compare 。前两次是去重【 !comp(a, b) && !comp(b, a)】，一次是内部红黑树的数据结构需要比较大小。
        constexpr bool operator<(const node& n)const {
            return this->val < n.val;
        }
    
    // 比较函数也可使用lambda表达式实现
    sort(startEnd.begin(), startEnd.end(), [](auto &a, auto &b){
                if(a[0] == b[0]) return a[1] < b[1];
                return a[0] < b[0];
            });
    ```

  * 容器元素**只能是对象类型，故引用不能作为元素。**

  * 注意：算法库中sort()要求自定义比较函数对象是 ，**静态/全局函数指针，非静态成员函数指针不能直接传递给std::sort()。**

  * 定义了数组后，就分配了相应空间，并**调用元素类型的默认构造函数。**

  * List容器为双向链表，其提供的void remove (const value_type& val);通过=运算符进行比较容器中的所有元素返回true的进行删除【先调用析构】，时间复杂度为O(n)。而std::[list](https://cplusplus.com/reference/list/list/)::erase(iterator posi)则是通过指定迭代器位置来进行删除，时间复杂度为O(1)。

  * std::unordered_map::erase有对指定键的删除还有指定迭代器位置的删除。

  * 解引用容器迭代器时返回的是元素引用，如果使用引用类型变量接收，元素删除后，该变量将会失效。

  * 在STL中，容器的元素要满足三个基本要求：可拷贝(copyable)、可赋值(assignable)、可析构(destroyable)。**基本数据类型和自定义的类都满足这些条件，但是引用不满足，因为引用不能析构**。

    * 可拷贝：容器插入元素时需要通过拷贝构造创建副本，注意元素为指针类型时，可能因重复析构和浅拷贝的原因导致内存泄漏问题。【对于含有堆资源的元素对象，我们一般实现深拷贝】

    * 可赋值：获取容器中的元素时需要重载赋值运算符的支持

  * set容器底层为红黑树，无法获取指定排序位置的元素，我们可以加入普通的vector后再进行排序然后获取指定位置的元素。

  * 容器只有基于deque实现的queue、stack和priority_queue的删除API名是pop，其他都是erase(iterator)

  * sort函数原型为void sort (RandomAccessIterator first, RandomAccessIterator last);传入的参数是迭代器，不是容器，内部实现为快排，即不稳定排序。

  * 字符串截取的API为

    ```c++
    basic_string substr( size_type pos = 0, size_type count = npos ) const;
    // 含子串 [pos, pos+count) 或 [pos, size()) 的 string 。
    ```

  * 容器【unordered_map、unordered_set、set】中找元素的API为find()，返回对应迭代器，找不到则返回容器::end();

  * 对于容器中的初始化，如果**类型参数T非类，则元素可能有不确定的值**，如果为类，则调用默认构造函数。

  * 成员变量初始化规则https://blog.csdn.net/littleflypig/article/details/89015638

  * 添加容器的方法

    * push_back() 在向容器尾部添加元素时，会**先创建这个元素，然后再将这个元素拷贝或移动到容器中**（若是拷贝的话，还需要在结束后销毁之前创建的这个元素）；
    * emplace_back() 则是**直接在容器尾部创建这个元素**，**省去了拷贝或移动元素的过程。**
    * https://zhuanlan.zhihu.com/p/213853588 todo阅读

* 前置++与后置++

  https://developer.aliyun.com/article/569874

  * **为了编译器区分前置和后置++**，**C++规定后缀形式有一个int类型参数**，当函数被调用时，**编译器传递一个0做为int参数的值给该函数**。不这样规定，无法区分，**因为都仅以自身对象为入参。**

  * ++操作符重载函数定义：

    ```c++
    前置++: type& operator++(){
        this->member+=1;
        return *this;
    }
    后置++: const type operator++(int ){
        type old = *this;
        ++(*this);
        return old;
    }
    ```

  * 前置比后置效率高，**后置需要构造临时对象并返回。**

  * 前置和后置返回类型不同的原因：

    * 前置返回引用确保可以**直接对这个返回对象再进行操作**，后置**返回的是临时对象不是原来的对象，对其操作没意义**，故**加const限制对返回对象的操作。**




## C++语法

* 浮点数表示：

  value of floating-point = **significand** x **base**^**exponent,** with its corresponding **sign**.
  
  sign：表正负
  
  significand：一系列数字，数字个数即精度。
  
  base：基底，用一个数字表示，2、10、16，对应数字的significand需用对应进制表示，基底默认为2，故实际存储的只有其他三部分。
  
  exponent：幂![image-20220904113551952](../../img/image-20220904113551952.png)https://www.cnblogs.com/chenny7/p/14251913.html
  
* 常见头文件

  ```c++
  #include <bits/stdc++.h> //万能
  #include <algorithm>
  #include <iostream>
  #include <string>
  #include <vector>
  #include <cstdlib> // 常用c函数
  #include <ctime> // 时间函数 设置不同的随机数种子
  #include <climits> // 表示整数类型上下的常量 INT_MAX 
  #include <cfloat> // 表示浮点数的limits FLT_MAX
  #include <cstdint> // 定义了specific width的整型和对应limits
  #include <cmath> // 引入数学运算
  #include <bitset> //获取整数和01字符串对应的bit序列
  #include <cctype> // 对字符的操作
  #include <utility> // 一些实用函数 如swap
  #include <memory> //内存安全相关 如多线程和智能指针
  ```

* 三角函数

  ```c++
  //cmath使用的是弧度值表示角度，范围为[0, pi]表示0-180度
  //一个弧度相当于180 /π度 acos(-1)等于pi
  cout << acos(0.5)*180/acos(-1);
  cout << sin(acos(-1)*30/180);
  ```

* char和unsigned char

  ```c++
      signed char a = 128; // 截取低8位存储 【第8位表正负 -128-127】
      // 这里为signed
      char b = 128; // 是否有符号根据编译器实现而定 ascii码范围0-127,[0,31]表示的是32个控制字符 其不可表示，能表示该范围的数即可
      unsigned char a1 = 128; // 截取低8位存储 【第8位不表正负 0-255】
  cout << a << endl; // 读取字节序列 根据文件的字符编码转换为相应字符 €
  cout << b << endl;  // €
  cout << a1 << endl;// 读取转换为相应字符 €
  ```

* switch的case里不能定义变量的原因：

  * case**跳转可能跳过了变量的定义**

* 面向对象：

  * ```c++
    #include<unordered_map>
    #include<list>
    #include<iostream>
    using namespace std;
    class Solution {
    private:
        // 记录迭代器
        unordered_map<int, std::list<pair<int, int>>::iterator> cache;
        // 双向链表
        list<pair<int, int>> list;
        int cap;
    public:
        Solution(int capacity) : cap(capacity) {
            // write code here
        }
    
        int get(int key) {
            // write code here
            if (cache.find(key) != cache.end()) {
                // auto 为pair 迭代器解引用返回引用 node使用引用进行构造
                auto node = *cache[key];
                // 去除对应位置的节点 常数时间复杂度
                list.erase(cache[key]);
                // 加入队头
                list.push_front(node);
                cache[key] = list.begin();
                return node.second;
            }
            return -1;
        }
    
        void set(int key, int value) {
            // write code here
            if (cache.find(key) != cache.end()) {
                auto& node = *cache[key];
                // todo erase不是析构了元素吗，为啥引用还可以用 
                // todo 插入元素是插入引用还是新拷贝了？
                node.second = value;
                // 去除对应位置的节点 常数时间复杂度
                list.erase(cache[key]);
                // 加入队头
                list.push_front(node);
                cache[key] = list.begin();
            }
            else {
                if (cache.size() == cap) {
                    auto toRemoNode = list.back();
                    cache.erase(toRemoNode.first);
                    list.pop_back();
                }
                auto node = make_pair(key, value);
                list.push_front(node);
                cache[key] = list.begin();
            }
        }
    };
    
    class Father {
    private:
        int data;
    public:
        // 非虚函数：派生类继承接口和实现
        void DoGetData(int d = 10) {
            data = d;
            // 调用的是子类的 通过对象虚指针找到对应虚函数执行【子类对象虚表中对应函数地址被替换】 多重继承才有多个虚指针，一般对象只有一个虚指针
            GetData();
        }
        virtual void GetData() {
            cout << data << endl;
        }
    
        // 纯虚函数 只有接口会被继承 默认实现不会被继承 对于派生类要求有对该纯虚函数的实现
        virtual void SetData(int d) = 0 {
            data = d;
        }
    };
    
    
    class Son : public Father{
    private:
        int data;
    public:
        void DoGetData(int d = 1) {
            data = d;
            GetData();
        }
        // void GetData() override{
        //    cout << data << endl;
        //} 同样效果
        virtual void GetData() {
            cout << data << endl;
        }
    
        // override 用来表明必须重写基类中的某个虚函数
        void SetData(int d) override{
            data = d;
        }
    };
    
    int main() {
        Son son;
        son.DoGetData(); // 1
        son.GetData(); // 1
        son.SetData(100);
        son.GetData();// 100
        son.Father::DoGetData();// 1 
        son.Father::GetData(); // 10
        son.Father::SetData(50);
        son.Father::GetData();// 50
        // Father f;// 无法创建纯虚函数对象
        Father* o = new Son;
        o->DoGetData(); // 随机值 调用的是 Father::DoGetData() 非虚函数属于静态绑定 子类同方法签名的非虚函数被掩盖了
        o->SetData(100);
        o->GetData(); // 
    }
    ```

  * 非虚成员函数：基类的接口和对应实现都会被继承，由于静态绑定只能根据声明的类型进行调用。

  * 成员虚函数：基类的接口和对应实现都会被继承，但是由于动态绑定机制，能被派生类的同名虚函数所覆盖。

  * 成员纯虚函数：只有接口会被继承 默认实现不会被继承 对于派生类要求有对该纯虚函数的实现 且无法创建声明有纯虚函数的类对象。

* 继承

  * 多重继承容易出现的问题：**命名冲突**和**数据冗余**问题。

    * 无间接继承一般使用声明属于哪一个类解决

      ```c++
      class a {
      public:
          int var1;
      };
      class b {
      public:
          int var1;
      };
      class c : public a, public b {
      public:
          void printVar1() {
              cout << a::var1 << endl;
          }
          
      };
      ```

    * 有间接继承可通过虚继承解决

      ```c++
      // 间接基类，即虚基类
      class Base1
      {
      public:
          int var1;
      };
      
      // 直接基类 
      class Base2 : virtual public Base1 // 虚继承
      {
      public:
          int var2;
      };
      
      // 直接基类 
      class Base3 : virtual public Base1 // 虚继承
      {
      public:
          int var3;
      };
      
      // 派生类
      class Derive : public Base2, public Base3
      {
      public:
          void set_var1(int tmp) { var1 = tmp; } 
          void set_var2(int tmp) { var2 = tmp; }
          void set_var3(int tmp) { var3 = tmp; }
          void set_var4(int tmp) { var4 = tmp; }
      
      private:
          int var4;
      };
      ```

      菱形继承中存在**对虚基类多次初始化的问题**，采用虚继承，可由**最底层的派生类直接负责虚基类的初始化。**默认的继承是**每个类只负责自己的直接基类的初始化**。

  * 调用函数时，内置类型做实参时，**使用值传递方式的效率要高于引用传递和指针传递**，因此编译器会采用效率最高的方式来实现参数传递，至于其他类型如自定义类，如果采用**值传递则会涉及拷贝构造函数和析构函数的调用问题**，通常会影响性能，所以一般采用**引用和指针传递的形式**，通常交由用户决定。

  * **某个类X的初始化顺序**，其实是一个递归初始化的过程，递归的终点是内置类型。

    1. 按照继承**声明顺序**，**初始化**基类对象。
    2. **初始化**X的成员对象。【声明顺序，不是初始化列表的顺序】
    3. 调用X构造函数

  * **禁止类的实例化**：

    * 1.定义**纯虚函数**，使该类成为**抽象基类**。
    * 2.构造函数声明为**private**。【可以**禁止直接实例化，不能禁止间接实例化**。如单例模式。】
    * 3.构造函数声明为**delete**。

  * 实例化对象的几个阶段

    * 1.分配空间

      **创建类对象首先要为该对象分配内存空间**。不同的对象，为其分配空间的时机未必相同。**全局对象、静态对象、分配在栈区域内的对象**，在**编译阶段进行内存分配**；存储**在堆空间的对象**，是在**运行阶段进行内存分配**。

      【2、3、4先父类再子类】

      2.如果当前类有虚函数，则为虚表指针赋值。【**虚函数表在编译期就会创建】**

      3.初始化

      成员变量初始化，根据调用函数的初始化列表进行，成员变量有默认值了。

      4.赋值

      构造函数中可能为成员变量赋值【调用拷贝赋值函数】，函数体执行完实例化就完成了。

  * **友元**的作用及使用场景

    * 作用：用`friend`在某个类中**修饰函数或类**相当于给该函数或类**访问该类私有成员或保护成员的许可**。

    * 友元函数：某些**虽然不是类成员函数却能够访问类的所有成员的函数。**类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。

      * ```c++
        #include <iostream>
        
        using namespace std;
        
        class A
        {
        public:
            friend void set_show(int x, A &a);      //该函数是友元函数的声明
        private:
            int data;
        };
        
        void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员 非类A成员函数 无需申明为类A作用域下
        {
            a.data = x;
            cout << a.data << endl;
        }
        int main(void)
        {
            class A a;
        
            set_show(1, a);
        
            return 0;
        }
        ```

    * 友元类：**友元类的所有成员函数都是另一个类的友元函数**，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。

      * 注意事项：

        * 友元关系**不能被继承**。
        * 友元关系是**单向的**，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
        * 友元关系**不具有传递性**。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。

      * ```c++
        #include <iostream>
        
        using namespace std;
        
        class A
        {
        public:
            friend class C;                         //这是友元类的声明
        private:
            int data;
        };
        
        class C             //友元类定义，为了访问类A中的成员
        {
        public:
            void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}
        };
        
        int main(void)
        {
            class A a;
            class C c;
        
            c.set_show(1, a);
        
            return 0;
        }
        ```

    * 友元成员函数：**使类B中的成员函数成为类A的友元函数**，这样类B的该成员函数就可以访问类A的所有成员了。

      * 注意事项：

        * 当用到友元成员函数时，需**注意友元声明和友元定义之间的相互依赖**
        * 更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。

      * ```c++
        #include <iostream>
        
        using namespace std;
        
        class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明
        class B
        {
        public:
            void set_show(int x, A &a);             //该函数是类A的友元函数
        };
        
        class A
        {
        public:
            friend void B::set_show(int x, A &a);   //该函数是友元成员函数的声明
        private:
            int data;
            void show() { cout << data << endl; }
        };
        
        void B::set_show(int x, A &a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员
        {
            a.data = x;
            cout << a.data << endl;
        }
        
        int main(void)
        {
            class A a;
            class B b;
        
            b.set_show(1, a);
        
            return 0;
        
        ```

    * 优点：

      *  可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务；

    * 缺点：

      * 一个类将对其非公有成员的访问权限授予其他函数或者类，会**破坏该类的封装性**，降低该类的可靠性和可维护性。

    * 场景：
      * **友元类**：类之间共享数据。
      * **普通函数定义为友元函数**，使普通函数能够访问类的私有成员。

  * 动态绑定和静态绑定

    https://blog.csdn.net/chgaowei/article/details/6427731

    * 对象的**静态类型**：对象在**声明时采用的类型**。是在**编译期**确定的。
    * 对象的**动态类型**：目前**所指对象的类型。**是在**运行期**决定的。对象的**动态类型可以更改**，但是**静态类型无法更改**。
    * 静态绑定：**绑定的是对象的静态类型**，某特性（比如函数）**依赖于对象的静态类型，发生在编译期**。
    * [动态绑定](https://so.csdn.net/so/search?q=动态绑定&spm=1001.2101.3001.7020)：**绑定的是对象的动态类型**，某特性（比如函数）**依赖于对象的动态类型，发生在运行期。**
    * 只有**虚函数才使用的是动态绑定**，**其他的全部是静态绑定**。【动态绑定 = 指针/引用 + 虚函数】
    * 虚函数是动态绑定的，但是为了执行效率，**缺省参数是静态绑定的。**

  * 深拷贝和浅拷贝的区别：

    https://www.cnblogs.com/hellowooorld/p/11259560.html

    * 深拷贝：深拷贝不但对指针进行拷贝，而且**对指针指向的内容进行拷贝**，经深拷贝后的指针是指向两个不同地址的指针【**拷贝栈空间和堆空间。**】
    * 浅拷贝：对指针的拷贝，拷贝后两个指针指向同一个内存空间【**只拷贝栈空间。**】
    * 默认的拷贝构造函数和拷贝赋值函数都是浅拷贝，当类中含有指针成员时一般需要重新定义两个函数。

  * 编译时多态和运行时多态的区别：

    * **编译时多态**：在程序编译过程中出现，发生在**模板**（泛型编程，根据**参数类型实例化不同的实例对象**）和**函数重载**中。
      
      * 函数重载：函数名称以及参数列表不同，返回类型可同可不同，编译后会形成不同的符号，代表不同的函数，占用不同的内存，入口地址也不同。
      
    * **运行时多态**：在程序运行过程中出现，发生在**继承体系**中，是指通过**基类的指针或引用访问派生类中的虚函数**。
  
      编译时多态和运行时多态的区别：

      * **时期**不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；
      * **实现方式**不同：编译时多态运用**泛型编程或函数重载**来实现，运行时多态借助**虚函数**来实现。
  
  * 类的成员函数后加const的作用
  
    * 类的成员函数后面加 const，表明这个函数**不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。**
  
      在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更加明确的限定：

      （1）有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。
      （2）除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是**常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。**
  
      **相当于对this指针做了底层const，只能保证this指向的内容不变。【指针常量和常量指针】**
  
      【常量成员函数中的this指针是常指针，无法通过this指针修改，只能读取】
  
    * const修饰的成员函数不能修改所有的数据成员，如果我们想要**在const成员函数修改部分的成员变量**时，可**为变量加上mutable修饰，表示该变量将永远处于可变的状态，即使在一个const函数中。**
  
      使用mutable的注意事项：
      （1）mutable**只能作用于类的非静态和非常量数据成员。**
      （2）在一个类中，**应尽量或者不用mutable**，大量使用mutable表示程序设计存在缺陷。
  
  * 如何**让类不能被继承**
  
    * 1、借助 `final` 关键字，用该关键字修饰的类**不能被继承**。
  
      ```c++
      class Base final
      ```
  
    * 2、借助**友元、虚继承和私有构造函数**来实现
  
      ```c++
      #include <iostream>
      using namespace std;
      
      template <typename T>
      class Base{
          friend T;
      private:
          Base(){
              cout << "base" << endl;
          }
          ~Base(){}
      };
      
      class B:virtual public Base<B>{   //一定注意 必须是虚继承 友元关系不能被继承 虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。
      public:
          B(){
              cout << "B" << endl;
          }
      };
      
      class C:public B{ // C类负责Base类的初始化，但是无法访问Base类的构造函数，故无法继承B
      public:
          C(){}     // error: 'Base<T>::Base() [with T = B]' is private within this context
      };
      
      
      int main(){
          B b;  
          return 0;
      }
      ```
  
  * 运算符
  
    * 不同的运算符对运算对象的要求各不相同，有的需要左值运算对象，有的需要右值运算对象，返回值也有差异，有的需要左值结果有的需要右值结果，但是有一个简单方法判断需要什么：![image-20230308124458685](../../img/image-20230308124458685.png)
  
    * 常见运算符重载方式：![image-20230308124542954](../../img/image-20230308124542954.png)
  
    * 运算符优先级：
    
      赋值运算符< 逻辑运算符 < 按位运算符 < 关系运算符 < 移位运算符 < 算术运算符 < **一元运算符** 【前面都是二元】< 成员访问运算符 < 作用域运算符
    
      ![image-20230308140624238](../../img/image-20230308140624238.png)
    
      ![image-20230308140736328](../../img/image-20230308140736328.png)
    
  * 右值引用和左值引用相关
  
    https://www.cnblogs.com/qicosmos/p/4283455.html
  
    https://blog.csdn.net/guangcheng0312q/article/details/103572987
  
    * C++标准中定义的值类别：![image-20221115221926730](../../img/image-20221115221926730.png)
  
      * 在C++11中所有的值必属于**左值、将亡值、纯右值**三者之一。
  
    * 左值【lvalue】：**有标识符、可以取地址**的表达式
  
      * 变量、函数或数据成员
  
      * 返回左值引用的表达式
  
        如 ++x、x = 1、cout << ' '
  
      * **字符串字面量**是左值，而且是不可被更改的左值。字符串字面量并不具名，但是可以用&取地址所以也是左值。
  
      * **左值引用是左值**、具名右值引用变量。
  
    * 纯右值(prvalue)：纯右值 prvalue 是**没有标识符**、**不可以取地址的表达式**，一般也称之为“临时对象”。
  
      * 返回非引用类型的表达式
  
        如 x++、x + 1
  
      * 除字符串字面量之外的字面量如 42、true
    
    * 将亡值(xvalue)：**有标识符，**所以也被称为glvalue。跟左值 lvalue 不同，xvalue 仍然是**不能取地址**的。
    
      * **调用函数的结果**，函数的**返回类型是对所返回对象类型的右值引用**
    
      * **将左值对象转换为右值引用的表达式。**【static_cast<int&&>()、std::move()】
    
      * 访问xvalue对象的成员的表达式
  
  * C++变量类型：
  
    * 值类型：表明一个变量是代表实际数值。**所有的原生类型、枚举、结构、联合、类都代表值类型。**
    * 引用类型：表明一个变量引用另外一个数值。**只有引用（&）和指针（*）才是引用类型。**
    * **一个表达式的lvalueness (左值性)或者 rvalueness (右值性)和它的类型无关。**
  
  * 左值引用：对**左值进行绑定**的引用，一个引号。
  
    *  **常量左值引用**是**万能的引用类型**，可以接受左值、右值、常量左值和常量右值。即使用**右值初始化时**，如果没有手写移动构造函数且编译器没为其提供默认移动构造函数时，则会**调用拷贝构造函数【其形参为常量左值引用且编译器一定会提供】**
  
  
  * **右值引用**：对**右值进行绑定的引用**就是右值引用，他的语法是这样的A&&，通过**双引号来表示绑定类型为A的右值**。【也相同于是左值因为具名了】
  
    特点：
  
    1、**绑定的右值的生命周期将会通过右值引用得以延续**，和右值引用变量的生命周期相同。【利用该特定进行性能优化，即**避免临时对象的拷贝构造和析构**】
  
  
  * 右值引用的作用：20240103
  
    * 减少临时对象**非必要的昂贵的拷贝操作**。
  
      * ```c++
        // 这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象
        T(T&& a) : m_val(a.m_val){ a.m_val=nullptr; }
        ```
  
      * 提供**深拷贝的拷贝构造函数**虽然可以**保证正确**【为避免指针悬挂】，但是在有些时候会造成**额外的性能损耗**。【函数返回时因**创建临时对象会调用拷贝构造**，用**函数返回值赋值时会调用拷贝构造**，赋值完后临时对象又会析构，两次拷贝一次析构，如果涉及的**堆内存**很大，将带来很大的损耗】![img](../../img/101140588706822.png)
  
      * 通过**移动构造函数来避免对临时对象进行深拷贝，而只是进行浅拷贝**，即**移动语义**。【将**对象资源的所有权从一个对象转移到另一个对象**，**只是转移**，没有内存的拷贝。】
  
      * 如果一个对象**内部有较大的堆内存或者动态数组时**，很有必要写move语义的**拷贝构造函数和赋值函数**，**避免无谓的深拷贝**，以提高性能。【没有对应的拷贝构造和拷贝赋值时，传入右值仍可以进行，**因为拷贝构造的常量左值引用形参仍能接受**】
  
      * move对于**含资源（堆内存或句柄）的对象**来说更有意义。
  
      * 可使用 **std::move 将左值变成右值引用**
  
    * 【**利用万能引用和forward函数实现完美转发**】在模板函数中确保**按照参数的实际类型进行转发。**
  
      * ```c++
        void processValue(int& a){ cout << "lvalue" << endl; }
        void processValue(int&& a){ cout << "rvalue" << endl; }
        template <typename T>
        void forwardValue(T&& val)
        {	
            // 如果无forward函数 直接传val 则走的都是lvalue【因为val是左值】
            processValue(std::forward<T>(val)); //照参数本来的值类别进行转发。
        }
        void Testdelcl()
        {
            int i = 0;
            forwardValue(i); //传入左值 
            forwardValue(0);//传入右值 
        }
        输出：
        lvaue 
        rvalue
        ```
        
      * C++11中的std::forward会**按照参数的实际类型进行转发。**
  
      * **T&&**是一个universal references，**可以接受左值或者右值**，这个特性让他适合**作为一个参数的路由**，然后再通过std::forward**按照参数的实际类型去匹配对应的重载函数**，最终实现**完美转发**。【要求T是一个**被推导的类型**，即**需要模板参数类型推导**的场景，如模板函数、auto关键字、typedef关键字、decltype关键字(与其他的规则不同)】
  
      * 万能引用参数类型推导规则：
  
        * **左值初始化则T&&变成左值引用**，模板参数T被推导为T& 总体为T& &&根据引用折叠规则，最终为左值引用。【**经过类型推导和引用折叠**】
        * **右值初始化则T&&变成右值引用**，模板参数T被推导为T，最终为右值引用。
        * 对于引用类型的变量，需先**去除引用部分，变为值类型**再作为**左值传递**，**故引用类型变量经过完美转发后得到的类型都是左值引用。**
  
    * <utility> **std :: move 函数和std::forward函数的实现原理**：
  
      * C++11确定了**引用折叠**的规则：【来处理某些像**模板实例化情况下带来的"引用的引用"**的问题。】
  
        - 所有的**右值引用叠加到右值引用上仍然还是一个右值引用；（A&& && 变成 A&&）**
      
        - 所有的**其他引用类型之间的叠加都将变成左值引用。（A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）**
      
        - 细节：
      
          - 引用的引用有四种可能【lvalue reference to lvalue reference, lvalue reference to rvalue reference, rvalue reference to lvalue reference, 以及 rvalue reference to rvalue reference】
  
          - 传入左值，根据类型推导规则，类型参数T被推导为T&，再根据引用折叠规则，T&&&折叠为T&，传入右值时，T被推导为T，最终为T&&。
  
            ```c++
            template<typename T>
            void f(T&& param);
             
            ...
             
            int x;
             
            ...
             
            f(10);                           // invoke f on rvalue等同于void f(int&& param);
            f(x);                            // invoke f on lvalue等同于void f(int& && param);
            ```
      
          - 注意：引用折叠**只会在一些特定的可能会产生"引用的引用"场景下生效**。 这些场景包括模板类型推导，`auto` 类型推导， `typedef` 的形成和使用，以及`decltype` 表达式。
      
          - todo https://zhuanlan.zhihu.com/p/99524127
      
      * typename的作用：
      
        * 模板编程时，**用于指定模板参数中的类型**
        * 声明**依赖于模板参数的名称为类型。**
      
      * **remove_reference(引用移除)**的实现
      
        * **基于对左值引用、右值引用的模板特化**实现
      
          ```c++
          
          //原始的，最通用的版本
          template <typename T> struct remove_reference{
              typedef T type;  //定义T的类型别名为type
          };
           
          //部分版本特例化，将用于左值引用和右值引用
          template <class T> struct remove_reference<T&> //左值引用
          { typedef T type; }
           
          template <class T> struct remove_reference<T&&> //右值引用
          { typedef T type; } 
          ```
      
      * move函数功能：**将一个左值强制转化为右值**，继而可以**通过右值引用使用该值，以用于移动语义。**
      
        函数原型：
      
        ```c++
        template <typename T>
        typename remove_reference<T>::type&& move(T&& t)
        {
        	return static_cast<typename remove_reference<T>::type &&>(t);
        }
        ```
      
        实现原理：
      
        * 通过 remove_refrence 移除引用，**得到具体的类型 T；**
        
        * 传递的是左值，推导为左值引用，仍旧`static_cast`转换为右值引用，**表达式结果为右值。**
        * 传递的是右值，推导为右值引用，仍旧`static_cast`转换为右值。
        
      * std::forward源码剖析：在传递参数的时候，可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数。】todo
      
        * 转发左值：【万能引用必走】
      
          ```c++
          template<typename _Tp>
          constexpr _Tp&&
          forward(typename std::remove_reference<_Tp>::type& __t) noexcept
          { return static_cast<_Tp&&>(__t); }
          ```
      
          type即为T，T& _t表示左值引用， _Tp为T&时 引用折叠为左值引用转换表达式结果为左值， _Tp为T&&时 引用折叠为右值引用转换表达式结果为右值。
      
      * 总结：
      
        * 在《Effective Modern C++》中建议：对于右值引用使用std::move，对于万能引用使用std::forward。
        * std::move()与std::forward()**都仅仅做了类型转换而已**。**真正的移动操作是在移动构造函数或者移动赋值操作符中发生的。**
        * std::move()可以应用于左值(普通的变量int这些使用move与不使用move效果一样)，但这么做**要谨慎。因为一旦“移动”了左值，就表示当前的值不再需要了**，如果后续使用了该值，产生的行为是未定义。
      
    * 函数返回类型相关细节：
  
      * 返回值类型：
        * 返回某个对象的副本【右值，函数执行完时发生拷贝在栈上创建的临时值】，这样需保证其是可拷贝【拷贝构造】或者可移动的【移动构造】。
      * 返回非常量左值引用：
        * 调用函数的表达式是左值，因为可取地址。
        * 和值类型的比较就是运行时不涉及拷贝构造和析构，减小对CPU的开销。
      * 返回常量左值引用：
        * 主要是避免对引用对象的修改。
      * 相关示例：
  
      ```c++
          Node getValue() {
      
          }
          Node& getNonConstReference() {
      
          }
          const Node& getConstReference() {
      
          }
          // todo 返回右值引用 Node&& getR
          void test() {
                      Node c = getValue(); // 编译器会实现拷贝构造其参数为常量左值引用 即万能引用
                      Node& b = getValue(); // 左值引用无法接收右值
                      Node&& a = getValue();// 右值引用接收
                      getValue().key = 5; // 右值对象无法修改
              
                      Node d = getNonConstReference(); // 拷贝构造
                      Node& e = getNonConstReference();
                      Node&& f = getNonConstReference(); // 右值引用不接收左值【可取地址】
                      getNonConstReference().key = 6; // 左值对象修改
              
                      Node g = getConstReference(); // 使用常量左值引用进行拷贝构造创建的g对象
                      g.key = 6; // 可对g进行修改
                      Node& h = getConstReference(); // 无法引用【必须修饰为常量】
                      const Node& i = getConstReference();
                      Node&& j = getConstReference(); // 右值引用不接收左值【可取地址】
                      getConstReference().val = 5; // 无法对常量对象修改
      
                  }
              
  
* 字符串：

     *  C风格字符串：即字符串字面量，为了表达和使用字符串而约定形成的写法，以空字符'\0'【%c方式输出为空格】标识字符串的结尾。![image-20230308134116520](../../img/image-20230308134116520.png)
       ​    
        * 必须用常量字符指针存储C风格字符串【存放在常量存储区不允许修改】![image-20230308134550138](../../img/image-20230308134550138.png)
     
* 指针与数组：

  * 【整型】：

    * **数组名可以当作指向数组第一个元素的指针**，a指向第一个元素，可以通过位移得到数组中的其他元素，其**进阶以数组中单个元素类型为单位**，即**a+i = &a[i]** 。
  * 一般取地址表示取得某个变量的存放地址，而如果对数组名a取地址，因为**变量a在内存中并没有分配空间，只是对数组a的各个元素分配了空间**，故对其取地址并不能取到a的地址。**&a在数值上等于&a[0]，也等于a**。此时，**&a数值上等于整个数组的起始位置地址**，**进阶单位是整个数组的字节长度**，**&a + 1** 等于的是数组结束之后的**下一段的起始位置地址**。![image-20230315000756929](../../img/image-20230315000756929.png)
  
* 【字符】
  
  * 标准输出流对于const char *有重载版本会将字符串完整输出。【**无法直接得出地址，可通过转为int *得出**】
  
  * 对于**字符名取地址输出又有地址**了[todo]
  
      ![image-20230315002347045](../../img/image-20230315002347045.png)
  
      

* 指针：

  * 定义：指向其他类型的**复合类型**

  * 大小：32bit，4字节，64bit，8字节

  * 用法：

    * 指向普通对象：A *p = new A();

    * 指向常量对象：

      ```c++
      const int c_var = 10;
      const int * p = &c_var;
      ```

    * 指向函数的指针：**函数指针**【ps：函数名即地址，可不加&】

      ```c++
      int add(int a, int b){
          return a + b;
      }
      
      int main(void)
      {	
          // 注意函数指针语法
          int (*fun_p)(int, int);
          fun_p = add;
          cout << fun_p(1, 6) << endl;
          return 0;
      }
      ```

    * 指向对象成员的指针：分为指向**对象成员变量和对象成员函数**，特别注意：**定义指向成员函数的指针**时，要**标明指针所属的类**。

      ```c++
      class A
      {
      public:
          int var1, var2; 
          int add(){
              return var1 + var2;
          }
      };
      
      int main()
      {
          A ex;
          ex.var1 = 3;
          ex.var2 = 4;
          int *p = &ex.var1; // 指向对象成员变量的指针
          cout << *p << endl;
      
          int (A::*fun_p)();
          fun_p = A::add; // 指向对象成员函数的指针 fun_p
          cout << (ex.*fun_p)() << endl;
          return 0;
      }
      ```

    * this指针：指向当前类对象的**指针常量**【顶层const】

  * 野指针和悬空指针？

    * **悬空指针**：**指针指向的内存空间已经被释放掉了**。

      ```c++
      void *p = malloc(size);
      free(p); 
      // 此时，p 指向的内存空间已释放， p 就是悬空指针。
      ```

    * **野指针**：“野指针”是指**不确定其指向**的指针，**未初始化的指针**、**指针释放后之后未置空**和**指针所指的对象已经消亡**为“野指针”。

      ```c++
      void *p; 
      // 此时 p 是“野指针”。
      ```

    * 如何避免野指针的出现：

      * 使用引用代替指针，如果使用引用可以达到编程目的，就可以不必使用指针。因为**引用在定义的时候，必须初始化，所以可以避免野指针的出现。**

      * 如果一定要使用指针，那么需要在定义指针变量的同时对它进行初始化操作。定义时**将其置为空或者指向一个有名变量。**

      * 对指针进行free或者delete操作后，**将其设置为NULL。**对于使用 free 的情况，常常定义一个宏或者函数 xfree 来代替 free 置空指针。

  * nullptr 和 NULL

    https://zhuanlan.zhihu.com/p/401919037

    * `nullptr`：C++ 11 中的关键字，是一种**特殊类型的字面值**，可以**被转换成任意其他指针类型**
    * `NULL`：**预处理变量，是一个宏**，它的值是 0，定义在头文件 <cstdlib> 中，即 `#define NULL 0`。
    * nullptr的优势：
      * **避免匹配重载函数时存在异议**：函数调用过程使用**NULL做实参传递且存在函数重载时**，可能出现存在异议的情况，但是**传递实参 `nullptr` 就不会出现这种情况。**
      * 更加健壮：**不同类型的指针变量都可以使用nullptr来初始化**，令我们编写的程序更加健壮。

  * 指针和引用的区别：

    * **相同点**：

      * 都是地址的概念，**指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。**

    * 是否**可变**：指针所指向的内存空间在程序运行过程中可以改变，而**引用所绑定的对象一旦绑定就不能改变**。

    * 是否占内存：

      * 指针本身在内存中占有内存空间

      * **引用是否占内存依据于编译器的具体实现**

        【无法通过sizeof得到引用所占内存，其得**到的是绑定的对象的大小。**】

        * 如果编译器**用指针实现引用**，那么它**占内存**。
        * 如果编译器**直接将引用替换为其所指的对象，则其不占内存**

    * 是否可为空：

      * **指针可以为空，但是引用必须绑定对象。**

    * 是否能为多级：

      * **指针可以有多级，但是引用只能一级。**

    * 指针从本质上讲就是**存放变量地址的一个变量**，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

    * 引用是一个别名，它在逻辑上不是独立的，它的**存在具有依附性**，所以引用必须在一开始就被初始化，而且**其引用的对象在其整个生命周期中是不能被改变的**（自始至终只能依附于同一个变量）。

    * 程序**在编译时分别将指针和引用添加到符号表**上，符号表上记录的是变量名及变量所对应地址。**指针变量在符号表上对应的地址值为指针变量的地址值**，而**引用在符号表上对应的地址值为引用对象的地址值**。**符号表生成后就不会再改**，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

  * 常量指针和指针常量：

    * **常量指针（const int *p 【与int const *p等同】修饰的是指向的对象）**：表示指向常量的指针，即底层const，**代表不可通过指针修改指向对象的数据，不一定要指向常量**，可以指向其他对象。
    * **指针常量（int * const p 修饰的是指针变量）**：**指针对象为常量，指针指向不可修改**。【顶层const】
    * **指向常量的指针常量（const int \* const p）**: p的指向不可修改，p所指的内存区域中的值也不可修改（是常量）。

  * 指针函数和函数指针

    * 指针函数：
      * 定义：**本质是一个函数**，只是**返回值是一个指针。**
      * 形式：`int* fun(int tmp1, int tmp2);` ，这里`*` 表示函数的返回值类型是指针类型。
    * 函数指针：
      * 定义：**本质是一个指针变量**，**指向函数的指针。**
      * 形式：`int (*fun)(int tmp1, int tmp2);`，这里`*` 表示变量本身是指针类型。

  * 强制类型转换：

    * 将**类型名作为强制类型转换运算符**的做法是c的老式做法，c++为**保持兼容而予以保留**。

      * 其有以下缺点：

        1、转换太过随意，可以**在任意类型之间转换。**

        2、**没有统一的关键字和标示符**。对于大型系统，做**代码排查时容易遗漏和忽略**。

    * C++ 引入了四种功能不同的**强制类型转换运算符**以进行强制类型转换：static_cast、reinterpret_cast、const_cast 和 dynamic_cast，

      用法如下：强制类型转换运算符 <要转换到的类型> (待转换的表达式)

      * static_cast：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。

        * a、用于**类层次结构中基类和派生类**之间**指针或引用**的转换；

          　　**上行转换**（派生类---->基类）是安全的。

          下行转换（基类---->派生类）由于**没有动态类型检查**，所以是不安全的。最好用 `dynamic_cast` 进行下行转换。（当类型不一致时，**转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题**）

        * b、用于**基本数据类型之间[不包括引用和指针]**的转换，如把int转换为char，安全性问题由开发者来保证；

        * c、把空指针转换成目标类型的空指针；

        * d、把任何类型的表达式转为void类型；

        * 使用特点

            * a、主要执行非多态的转换操作，用于**代替C中通常的转换操作；**
            * b、**隐式转换都建议使用static_cast进行标明和替换**；
      
            ```c++
            class A
            {
            public:
                // 如果对象所属的类重载了强制类型转换运算符 T（如 T是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。
                operator int() { return 1; }
                operator char*() { return NULL; }
            };
            
            int main()
            {
                A a;
                int n;
                char* p = "New Dragon Inn";
            
                n = static_cast <int> (3.14);  // n 的值变为 3
                n = static_cast <int> (a);     // 调用 a.operator int，n 的值变为 1
                p = static_cast <char*> (a);   // 调用 a.operator char*，p 的值变为 NULL
                n = static_cast <int> (p);     // 编译错误，static_cast不能将指针转换成整型
                p = static_cast <char*> (n);   // 编译错误，static_cast 不能将整型转换成指针
            
                return 0;
            }
            ```

  * const_cast：**强制去掉常量属性**，不能用于去掉变量的常量性，只能用于**去除指针或引用**的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用。【**指针和引用的基本类型要相同**】

       * 使用特点：

         * cosnt_cast是四种类型转换符中**唯一可以对常量进行操作的转换符**

         * 去除常量性是一个**危险的动作**，尽量避免使用。

```c++
const string s = "Inception";
            string& p = const_cast <string&> (s);
            string* ps = const_cast <string*> (&s);  // &s 的类型是 const string*
```

  * reinterpret_cast：用于进行**各种不同类型的指针之间**、**不同类型的引用之间**以及**指针和能容纳指针的整数类型之间的转换**。转换时，执行的是**逐个比特复制的操作。**

    * 使用场景：不到万不得已，不用使用这个转换符，高危操作；

    * 使用特点：reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差；


​    

  * ```c++
       class A
       {
       public:
           int i;
           int j;
           A(int n) :i(n), j(n) { }
       };
       
       int main()
       {
           A a(100);
           int &r = reinterpret_cast<int&>(a);             // 强行让 r 引用 a
           r = 200;                                                            // 把 a.i 变成了 200
           cout << a.i << "," << a.j << endl;                  // 输出 200,100
           int n = 300;
           A *pa = reinterpret_cast<A*> (&n);              // 强行让 pa 指向 n
           pa->i = 400;                                                    // n 变成 400
           pa->j = 500;                                                    // 此条语句不安全，很可能导致程序崩溃
           cout << n << endl;                                          // 输出 400
           long long la = 0x12345678abcdLL;
           pa = reinterpret_cast<A*>(la);                      // la太长，只取低32位0x5678abcd拷贝给pa
           unsigned int u = reinterpret_cast<unsigned int>(pa);    // pa逐个比特拷贝到u
           cout << hex << u << endl;                               // 输出 5678abcd
           typedef void(*PF1) (int);
           typedef int(*PF2) (int, char *);
           PF1 pf1 = nullptr; 
           PF2 pf2;
           pf2 = reinterpret_cast<PF2>(pf1);                   // 两个不同类型的函数指针之间可以互相转换
       }
       ```

  * dynamic_cast：

    * 其他三种都是**编译时完成的**，**动态类型转换**是在**程序运行时处理的**，**运行时会进行类型检查。**

    * 只能用于**带有虚函数的基类或派生类的指针或者引用对象的转换**，转换成功返回指向类型的指针或引用，**转换失败返回 `NULL`**；**不能用于基本数据类型的转换。**

【**运行时的类型信息需通过虚函数表获取**】

* 在**向上进行转换**时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是**改变了指针的类型**，指针指向的对象的类型并未发生改变）。【向上类型转换不需要虚函数，**向上转换永远是安全的**】

* 在**下行转换**时，基类的指针类型转化为派生类类的指针类型，**只有当要转换的指针指向的对象类型为转化以后的对象类型及其派生类时**，才会转化成功。

  * 其他类型转换的场景：
    * 条件运算符的隐式转换：
      ![image-20220923213547596](../../img/image-20220923213547596.png)
           
      
      ```c++
          unsigned int a = 5;
          cout << (true ? -1 : a)<< endl;// 输出转化为左值a的类型unsigned int即-1[类型为signed int]的字节序列用sigend int表示 即4294967295
      ```

* 指针数组和数组指针

  * 不论指针变量的类型是什么，在同一个平台下大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。


  * **指针数组**实质是一个数组，**数组内元素全部是指针变量**； **数组指针**实质是一个指针，该**指针指向一个数组**; 
        区分两者，若**核心和星号\*结合**,表示核心是**指针**如int **(\*n)**[10]，指向int [10]，表示数组指针。
        若**核心和中括号[]结合**，表示核心是**数组**,如 int ***p[10****]**，内部元素为int \*，表示指针数组
        若核心和小括号结合，表示核心是函数，如int **q()**；
        遇到操作符优先级问题，看优先级高低,其中（）、[ ]、->优先级高于\*

    * **指针+1所得结果要根据指针类型加上一定的值**，不同类型的指针+1之后增加的大小不同，a是长度为5的int数组指针，所以要加5*sizeof(int)

      ```c++
      int main(void) {
           int a[5] = {1, 2, 3, 4, 5};
          // &a 类型为int[5] * 即指向长度为5的数组  &a + 1 即地址值加上5*sizeof(int)
          // (int *) 转为指向int类型的指针
           int *ptr = (int *)(&a + 1);
          // *(a + i) == a[i];
           printf("%d %d", *(a + 1), *(ptr - 1)); //输出 2 5
           return 0;
       }
      ```

  * 结构体相关

    * 如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？

      * 不能有memcmp函数进行比较，因为**memcmp函数是逐个字节比较的**，结构体在内存空间保存时存在字节对齐，字**节对齐时补充的字节内容是随机的**，**无法进行比较**。

      * 可通过重载操作符==来进行比较

        ```c++
        #include <iostream>
        
        using namespace std;
        
        struct A
        {
            char c;
            int val;
            A(char c_tmp, int tmp) : c(c_tmp), val(tmp) {}
        
            friend bool operator==(const A &tmp1, const A &tmp2); //  友元运算符重载函数 友元函数不含this指针 故符合==需要两个操作数的需求
        };
        
        bool operator==(const A &tmp1, const A &tmp2)
        {
            return (tmp1.c == tmp2.c && tmp1.val == tmp2.val);
        }
        
        int main()
        {
            A ex1('a', 90), ex2('b', 80);
            if (ex1 == ex2)
                cout << "ex1 == ex2" << endl;
            else
                cout << "ex1 != ex2" << endl; // 输出
            return 0;
        }
        ```

    * C 和 C++ struct的区别：

      * 在 C 语言中 struct 是**用户自定义数据类型，struct 没有访问权限的设置，是一些变量的集合体，定义该类型的变量时，需要加上 struct 关键字，不能定义成员函数**；在 C++ 中 struct 是**抽象数据类型，定义该类型的变量时不用加该关键字， 可以和类一样，有访问权限，并可以定义成员函数。**

    * Class 和 struct的异同：

      * `struct` 和 `class` 都可以**自定义数据类型**，也支持**继承操作**。
      * **成员的默认访问权限和默认的继承级别**。**struct默认是public，而class默认是private。**
        * 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，**基类的私有成员不能直接被派生类访问**，但是可以通过调用基类的公有和保护成员来访问。
        * 保护继承（protected）： 当一个类派生自保护基类时，**基类的公有和保护成员将成为派生类的保护成员。**
        * 私有继承（private）：当一个类派生自私有基类时，基**类的公有和保护成员将成为派生类的私有成员。**
      * 当 class 继承 struct 或者 struct 继承 class 时，默**认的继承级别取决于 class 或 struct 本身**， class（private 继承），struct（public 继承），即**取决于派生类的默认继承级别。**
      * `class` **关键字**可以用于**定义模板参数**，`struct` **不能用于定义模板参数**。

    * 有了Class还保留struct的原因：

      - C++ 是在 **C 语言的基础上发展起来的，为了与 C 语言兼容**，C++ 中保留了 `struct`。

    * struct和union的区别

      * 说明：`union` 是**联合体**，`struct` 是**结构体**。

      * 区别：

        * 联合体和结构体**都是由若干个数据类型不同的数据成员组**成。使用时，**联合体只有一个有效的成员；而结构体所有的成员都有效。**

        * **对联合体的不同成员赋值，将会对覆盖其他成员的值**，而**对于结构体的对不同成员赋值时，相互不影响。**

        * 联合体的大小为其内部所有变量的最大值，**按照最大类型的倍数进行分配大小**；**结构体分配内存的大小遵循内存对齐原则**。

          [如果union中**包含了类的话，最大类型可能为类的对齐参数**]。

    * 参数传递的区别

      https://www.cnblogs.com/huolong-blog/p/7588335.html

      * 值传递：
        * 值传递过程中，**被调函数的形式参数作为被调函数的局部变量处理**，即在**栈中开辟了内存空间以存放由主调函数放进来的实参的值**，**从而成为了实参的一个副本**。
        * 值传递的特点是被调函数对形式参数的任何操作都是**作为局部变量进行**，不会影响主调函数的实参变量的值。（这里是在说**实参指针本身的内容不会变**）
      * 引用传递：
        * 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是**由主调函数放进来的实参变量的地址。**
        * 被调函数**对引用形参的任何操作**都被处理成**间接寻址**，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

    * decltype作用：

      * 解决了`auto`关键字**只能对变量类型进行类型推导的缺陷**

      * decltype关键字可用来对表达式进行类型推导

        ```c++
        decltype(表达式)
        ```

        

    * 尾置返回类型：

      * 用于**函数返回类型的自动推导**，一般用于**返回类型比较复杂**，或者需要**通过模板参数（亦或其它表达式）来推导返回类型**的情况，通常会结合 **decltype** 一起使用，本质上算是一种语法糖，在函数定义的**参数列表右侧添加 ->ReturnType** 来**代表函数返回类型**，将**通常放置函数返回类型的地方使用 auto 代替**。

      * 语法格式：

        ```cpp
        auto FuncName(ArgsList) -> ReturnType { }
        ```

      * 实例：

        ```c++
        // 结合decltype，依据模板参数推导返回类型 
        template<typename ArgType1, typename ArgType2>
        auto Func1(ArgType1& a, ArgType2& b) -> decltype(a + b) 
        { 
            return (a + b);
        }
        
        // 在C++14中可省略箭头返回值部分，直接将函数返回类型设置为auto 
        template<typename ArgType1, typename ArgType2>
        auto Func2(ArgType1& a, ArgType2& b)
        { 
            return (a + b);
        }
        
        // 也可以直接将返回类型定义为 decltype(auto) 
        template<typename ArgType1, typename ArgType2>
        decltype(auto) Func3(ArgType1& a, ArgType2& b)
        {
            return (a + b);
        }
        ```

        **特别注意：**对于 Func1、Func2 和 Func3 的**函数定义是等价的**，当它们都是相同函数名时相当于**定义了多个相同的重载函数**，但是这种等价的定义在**不使用时不会导致编译报错**，而在实际**调用**中，会因为对**重载函数的不明确调用**而导致编译报错。

      * 尾置返回类型出现的原因：将尾置返回类型放在参数列表后面，是因为C++函数的**返回类型是前置定义**，**在前置定义中，此时还未定义参数列表，所以如果要通过参数来推导返回类型就必须将推导的表达式放在参数列表后面，**C++14虽然可以省略类型推导表达式，但仍然不能在前置定义的返回类型中依据参数推导返回类型：

        ```c++
        // 编译报错，找不到 a 和 b 的定义 
        template<typename ArgType1, typename ArgType2>
        decltype(a + b) Func4(ArgType1& a, ArgType2& b)
        {
            return (a + b);
        }
        
        // 需要注意的是上述代码不代表 decltype 不能用于函数前置声明【其只是不能通过参数来推导返回类型】，如：
        vector<int> VEC;
        template<typename ArgType1, typename ArgType2>
        decltype(VEC) Func5(ArgType1 a, ArgType2 b)
        {
            vector<int> arr{a, b};
            return arr;
        }
        ```

    * 函数返回类型：由函数声明时指定的返回类型决定，不是return表达式的类型决定。

      https://blog.csdn.net/cainv89/article/details/47344587

  * static：

    https://blog.csdn.net/leikun153/article/details/80563903

    * 作用：
      * **保持变量内容持久**：static作用于局部变量，改变了局部变量的生存周期，使得该变量**在定义后直到程序运行结束期间一直存在**。
      * **隐藏**：static作用于全局变量和函数，**改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，不再具有全局可见性。**
      * 为属于一类的不同对象提供共享的静态成员使用。

    * 静态函数

      * **静态函数的作用域为当前的源文件，普通函数的作用域为整个工程**。但是静态函数会被**一直放在一个一直使用的存储区**，直到退出应用程序实列，避**免了调用函数时的压栈和出栈，速度快很多。**

    * 静态变量

      * 静态全局变量：

        * 生命周期：全局变量无论是否是静态的，**其生命周期都是从定义该变量该开始，直到程序结束时。**

        * 作用域：**静态全局变量的是包含它当前的源文件**，该工程的**其他源文件是不可以访问它**的。【**内部链接性**】

          【这样做的好处是多人联合开发时，**不必担心变量名冲突问题**。】

          【普通全局变量的的作用域是**当前的整个工程，整个工程里的不同文件可以共享全局变量。**外部链接性】

        * 静态全局变量和普通全局变量**都存放在全局数据区，如果没有初始化，系统将其自动初始化为0。**

        * 构造顺序：**全局变量最先构造，早于`main`函数，当然，析构函数也是执行的最晚，晚于`main`函数。**

      * 静态局部变量：

        * 生命周期：全局的，**在程序执行完毕后释放**，而**不会在某个当前函数执行完就释放**。
        * 存储位置：静态局部变量存储在**全局数据区**。【**普通局部变量存放在栈中，随函数执行完毕后自动释放**】
        * 初始化：**对静态局部变量的初始化只会执行一次**，默认初始值为0。【**普通局部变量初始值随机，但是每一次合法初始化都会执行。**】
        * 作用域：只在局部有效。
        * 构造顺序：**等到执行该声明定义的表达式后，才开始执行构造的**。当然，析构函数也是早于全局变量的。

    * 静态成员【static在C++中的扩展】：

      * 静态数据成员：
        * 定义：静态数据成员是属于整个类的，而不是属于某个对象。即不管实例多少个对象，它们都**公用一个静态数据成员。**
        * 初始化：**类内部进行声明，类外部定义**，**如果不在类外赋初值，则自动初始化为0。**
        * 存储位置及生命周期：静态数据成员存储在**全局数据区**，因为**静态数据成员的生命周期比一个具体的类对象更长一些**，在类对象存在之前就已经存在。
      * 静态成员函数：
        * 定义：静态成员函数也是属于整个类的，但是不属于任何一个对象。它是**某个类所有对象共享的一个函数。**
        * 因为静态成员函数**不属于任何对象**，所以**静态数据成员函数并没有this指针**，所以它无法来访问普通的数据成员，它**只能调用其余的静态成员**，也**不能声明为const**。

    * 注意事项：

      * 访问静态成员：
        * 使用作用域运算符直接访问
        * 通过类对象、引用或者指针访问
        * 静态成员函数无需通过作用域运算符即可访问
      * 一般来说，静态成员变量在类内进行声明，在类外进行定义和初始化。
        * 因为静态数据成员并不是在创建类的对象时被定义的，即不是由类的构造函数初始化的。
        * 定义格式：类型名、类名、作用域运算符以及成员名![image-20230304171103198](../../img/image-20230304171103198.png)
        * 如果静态数据成员是**字面值常量类型的constexpr**或者常量类型，静态数据成员可在类内进行初始化![image-20230304172407850](../../img/image-20230304172407850.png)
        * 静态成员和普通成员的区别：
          * 静态数据成员可以是不完全类型，特别地**静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。**![image-20230304171341293](../../img/image-20230304171341293.png)
          * 可使用静态数据成员作为默认实参，而非静态数据成员不能作为默认实参。因为其是对象的一部分。![image-20230304171536075](../../img/image-20230304171536075.png)
      * 静态成员函数可在类内或类外定义。
        * ![image-20230304171939844](../../img/image-20230304171939844.png)![image-20230304171952931](../../img/image-20230304171952931.png)
      * 静态成员函数**不能声明成虚函数（`virtual`）、`const` 函数和 `volatile` 函数。**
        * 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，**并且只能用this指针来访问它**，因为它是类的一个成员，并且**vptr指向保存虚函数地址的vtable.**
        * 对于静态成员函数，它**没有this指针，所以无法访问vptr.** 这就是为何static函数不能为virtual.
        * 虚函数的调用关系：this -> vptr -> vtable ->virtual function
        * static成员函数没有this指针，即没有指向的对象，所以**使用const来修饰static成员函数没有任何意义。**
        * volatile的道理也是如此。

    * 线程安全：

        * 编译时可初始化的static变量【静态初始化】，初始化发生在编译时，不会出现线程安全问题。

        * 运行时初始化的static变量【动态初始化】还是编译器通过flag区分变量的构造状态来保证线程安全的https://stackoverflow.com/questions/34457432/c11-singleton-static-variable-is-thread-safe-why

  * const：

    * 作用：
      * const 修饰**变量**，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。[const成员变量只能在类内声明、定义，**在构造函数初始化列表中初始化。**]
      * const 修饰**函数参数**，使得传递过来的**函数参数的值不能改变。**
      * const 修饰**成员函数**，使得成员函数**不能修改任何类型的成员变量**（**mutable 修饰的变量除外**），也**不能调用非 const 成员函数**，因为非 const 成员函数可能会修改成员变量。
      
    * **和define的区别**

      * 编译阶段：define 是在**编译预处理阶段**进行替换，const 是在**编译阶段确定其值**。

      * 安全性：define 定义的**宏常量没有数据类型，只是进行简单的代码替换**，不会进行类型安全的检查；const 定义的常量是**有类型的，是要进行判断的**，可以避免一些低级的错误。

      * 存储空间：define 定义的宏定义只是作为代码替换的表达式而已，**宏定义本身不占内存空间**，define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，实际使用宏定义替换代码时占用的是代码段的空间；const 定义的全局常量占用静态存储区的只读空间，程序运行过程中常量只有一份。

      * 调试：define 定义的**宏常量不能调试**，因为在**预编译阶段就已经进行替换了**；const 定义的常量可以进行调试。

      * define 可以**接受参数构造非常复杂的表达式**，const **不能接受参数**。

        ```c++
        #include<iostream>
        using namespace std;
        int main()
        {
            int a=1;
            #define T1=a+a
            #define T2=T1-T1 
            cout<<T2<<endl; // 2
            return 0;
        }
        ```

  * define 和 typedef 的区别：

    * 原理：**#define 作为预处理指令**，**在编译预处理时进行替换操作，不作正确性检查**，只有在编译**已被展开的源程序时才会发现可能的错误并报错**。**typedef 是关键字**，在编译时处理，有**类型检查功能**，用来给一个**已经存在的类型定义一个别名**。

    * 功能：typedef 用来定义**类型的别名**，方便使用。#define 不仅可以**为类型取别名**，还可以定义**常量、变量、编译开关**等。

    * 作用域：

      * typedef：

        如果放在所有函数之外，它的作用域就是**从它定义开始直到文件尾**；

        如果放在某个函数内，定义域就是**从定义开始直到该函数结尾**；

      * #define：

        不管是在某个函数内，还是在所有函数之外，**作用域都是从定义开始直到整个文件结尾。**

    *   指针的操作：typedef 和 #define **在处理指针时不完全一样**

      * ```c++
        #include <iostream>
        #define INTPTR1 int *
        typedef int * INTPTR2;
        
        using namespace std;
        
        int main()
        {
            INTPTR1 p1, p2; // p1: int *; p2: int
            INTPTR2 p3, p4; // p3: int *; p4: int *
        
            int var = 1;
            const INTPTR1 p5 = &var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。
            const INTPTR2 p6 = &var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。
            
            return 0;
        }
        ```

  * 用宏**实现比较大小**，以及**两个数中的最小值**

    ```c++
    #include <iostream>
    #define MAX(X, Y) ((X)>(Y)?(X):(Y)) // define只是文本替换，不带括号可能会出现歧义s
    #define MIN(X, Y) ((X)<(Y)?(X):(Y))
    using namespace std;
    
    int main ()
    {
        int var1 = 10, var2 = 100;
        cout << MAX(var1, var2) << endl;
        cout << MIN(var1, var2) << endl;
        return 0;
    }
    /*
    程序运行结果：
    100
    10
    */
    ```

  * 内联函数：

    * 定义：**建议编译器在调用时并不通过函数调用的机制而是直接在调用点处展开**。【一般是当一个**函数调用的时候**，**压入栈所需要的指令比这个函数执行的指令多的时候**。这个时候调用函数的压入和弹出栈的操作就显得很多余，**编译器就会直接在调用点展开**。】
    * 规则：**类内定义的成员函数默认为内联函数**，类外定义的成员函数可在声明时添加inline关键字使其成为内联函数，普通函数加inline关键字成为内联。
    * 工作原理：
      * 内联函数**不是在调用时发生控制转移关系**，而是**在编译阶段将函数体嵌入到每一个调用该函数的语句块中**，编译器**会将程序中出现内联函数的调用表达式用内联函数的函数体来替换**。
      * **普通函数在运行的过程**中，在函数所在位置**生成一个断点，保存此时的状态**，然后再**栈中压入一个函数体**。执行完该函数体后释放。释放后，**链接断点**。这些操作产生的**额外开销**。内联函数的目的就是**减少这些额外开销**。
    * 优点：消除**函数调用的开销**。
    * 缺点：可能引起**代码膨胀**。
    * inline和define[宏定义]的区别
      * **内联函数是在编译时展开**，而**宏在编译预处理时展开**；在编译的时候，**内联函数直接被嵌入到目标代码中去**，而**宏只是一个简单的文本替换**。
      * **宏定义只进行文本替换**，**不会对参数的类型、语句能否正常编译等进行检查。**而**内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查**。

  * new的作用：

    https://blog.csdn.net/xiaorenwuzyh/article/details/44514815

    * `new` 是 `C++` 中的**关键字**，也是**操作符**，**new关键字的作用是尝试分配和初始化指定类型的对象或对象数组，并返回指向对象 (或数组的初始对象) 的指针。**

      * 工作流程：首先**从堆中申请相应的内存空间**，然后**调用对象的构造函数，最后返回指向对象的指针。**

    * new关键字通过调用 **函数operator new 和 palcement new 来实现**

      ```c++
          class A {...}  //声明一个 类 A
          A *ojb = new A();    // 实际先通过全局的operator new进行内存分配 编译器会获取对应类型的大小作为参数传递 在进行placement new操作 最后会进行指针转化操作
      ```

    * operator new：

      * 默认的全局operator new为**调用malloc分配空间**

        ```c++
        // 全局 operator new
        void * operator new(std::size_t size) throw(std::bad_alloc) {
            if (size == 0)
                size = 1;
            void* p;
            while ((p = ::malloc(size)) == 0) { //采用 malloc 分配空间
                std::new_handler nh = std::get_new_handler();
                if (nh)
                    nh();
                else
                    throw std::bad_alloc();
            }
            return p;
        }
        ```

      * 可对 operator new 进行重载，实现自己的内存分配。

    * placement new：

      https://zhuanlan.zhihu.com/p/228001107

      * 定义：即**定位放置new**，在某些特殊情况下，可能需要**在已分配的特定内存调用构造函数来初始化指定类型的对象**，以达到**内存复用**的目的。【如果没有placement new则会缺失初始化数据，定义了虚析构函数的类会缺失虚指针，调用delete时找不到正确的虚析构函数】

      * 调用的new操作：

        void * operator new (size_t,void *)  // 不允许重定义这个版本的operator new

        **不是一个（写在文件中）函数，是编译器编译时候做的事情。**

        【利用已经**申请好的空间，真正的申请空间的工作是在此之前完成的**】

      * 语法形式：A* p=new (ptr)A;申请空间，其中ptr就是**程序员指定的内存首地址。**

      * 优点：**对内存的重复利用，避免了内存的多次申请和多次释放，同时避免了系统生成大量的内存碎片。**

      * 注意：定位生成对象时，会自动调用类A的构造函数，但是由于**对象的空间不会自动释放（对象实际上是借用别人的空间）**，所以必须**显示的调用类的析构函数**

    * new 和 malloc的区别：

      https://www.cnblogs.com/ywliao/articles/8116622.html![image-20220918172518522](../../img/image-20220918172518522.png)

      相关概念：

      自由存储区：**new所申请的内存区域在C++中称为自由存储区。**

      realloc先判断**当前的指针所指内存是否有足够的连续空间**，如果有，**原地扩大可分配的内存地址**，并且返回原来的地址指针；如果空间不够，**先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。**

  * delete的作用：

    * delete也有关键字和表达式之分，关键字的作用是**先执行析构，再调用相应的operator delete来释放所占的内存空间。**【即**placement delete + operator delete**】

    * 要求被释放的指针必须是**指向动态分配的内存空间的指针**，否则会出错。

    * 释放后指针还是存储着对应的地址不会变成空。

    * operator delete：

      * **全局版本调用free释放空间**:

        ```c++
        // 对应的全局 operator delete 采用 free 释放空间
        void operator delete(void* ptr) {
            if (ptr)
                ::free(ptr); //采用 free 释放空间。
            // 只需传入一个指针 故有某个地址记录了分配内存块的大小 一般实现是在malloc返回指针的前一个指针有记录
        }
        ```

      * 注意如果自己的operator delete有实现，则调用自己的实现，需注意和operator new约定内存分配和释放【一般是malloc和free】

    * delete和delete []的区别

      * delete 用来**释放单个对象所占的空间**，**只会调用一次析构函数**；【使用 `new` 分配内存，使用 `delete` 来释放。】
      * delete [] 用来**释放数组空间**，会**对数组中的每个成员都调用一次析构函数**。【使用 `new[]` **分配数组类型的内存**，使用 `delete[]` 来释放。】
      * 注意：
        * 内置类型没有析构函数，调用delete和delete[]作用一样，不会内存泄漏
        * 对于自定义类型，由于 delete p 只调用了一次析构函数，剩余的对象不会调用析构函数，所以剩余对象中**如果有申请了新的内存或者其他系统资源，**那么**这部分内存和资源就无法被释放掉了，因此会造成内存泄露或者更严重的问题。**【如果没有申请的话，其实没有差别】

  * malloc的原理

    * https://zhuanlan.zhihu.com/p/57863097

* 常见库函数

  * memcpy和memmove

    https://blog.csdn.net/li_ning_/article/details/51418400

    * 作用：在头文件string.h中，作用是**拷贝一定长度的内存的内容**

      ```c++
      void *memcpy(void *dst, const void *src, size_t count);
      void *memmove(void *dst, const void *src, size_t count);
      ```

      唯一的区别是，**当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。**

    * memcpy的实现：

      从内存左侧一个字节一个字节地将src中的内容拷贝到dest的内存中，这种拷贝方式可能使得拷贝结果不正确。

      ```c++
      void* my_memcpy(void* dst, const void* src, size_t n)
      {
          char *tmp = (char*)dst;
          char *s_src = (char*)src;
       
          while(n--) {
              *tmp++ = *s_src++;
          }
          return dst;
      }
      ```

    * memmove的实现：

      分情况实现，如果存在源地址和目的地址存在内存重叠且源地址比目的地址小时，则**从内存的右侧往左一个字节一个字节的拷贝，否则直接从左侧开始拷贝。**

      ```c++
      void *memmove(void *dst, const void *src, size_t size)
      {
          char *psrc;
          char *pdst;
      
          if (NULL == dst || NULL == src)
          {
              return NULL;
          }
      
          if ((src < dst) && (char *)src + size > (char *)dst) // 出现第二种地址重叠的情况，自后向前拷贝
          {
              psrc = (char *)src + size - 1;
              pdst = (char *)dst + size - 1;
              while (size--)
              {
                  *pdst-- = *psrc--;
              }
          }
          else
          {
              psrc = (char *)src;
              pdst = (char *)dst;
              while (size--)
              {
                  *pdst++ = *psrc++;
              }
          }
      
          return dst;
      }
      ```

  * strcpy函数

    * 作用：`C++` 语言的一个标准函数 ，**`strcpy` 把含有 `'\0'` 结束符的字符串复制到另一个地址空间**，返回值的类型为 `char*`，返回值为拷贝后的字符串的首地址。

      ```c++
      char * strcpy(char * strDest,const char * strSrc) {
          if ((NULL==strDest) || (NULL==strSrc)) 
          throw "Invalid argument(s)"; 
          char * strDestCopy = strDest; 
          // 从内存低地址到高地址逐字节进行拷贝
          while ((*strDest++=*strSrc++)!='\0'); 
          return strDestCopy;
      }
      ```

    * 缺陷：strcpy 函数**不检查目的缓冲区的大小边界**，而是将源字符串**逐一的全部赋值给目的字符串地址起始的一块连续的内存空间**，同时加上字符串终止符，会导致其他变量被覆盖。

      小端模式：高字节位于高地址，低字节位于低地址。

      栈区：**从高地址向低地址扩展**，即**分配整块内存时从高地址向低地址方向分配**。局部变量存储在栈区。【分配是向高地址扩展，写的时候还是从低地址写到高地址（字符串是如此，数值也是如此【小端模式】）】

      ```c++
      int main()
      {
          int var = 0x11112222;
          char arr[10];
          cout << "Address : var " << &var << endl;
          cout << "Address : arr " << &arr << endl;
          strcpy(arr, "hello world!");
          cout << "var:" << hex << var << endl; // 将变量 var 以 16 进制输出
          cout << "arr:" << arr << endl;
          return 0;
      }
      
      /*
      Address : var 0x23fe4c
      Address : arr 0x23fe42
      var:11002164
      arr:hello world!
      */
      ```

      ![image.png](../../img/1627822193-yqLShF-image.png)


* 泛型编程相关：

  * 模板的定义以及实现

    * 定义：创建**类或者函数的蓝图或者公式**，分为**函数模板和类模板。**

    * 模板与继承或者组合的关系：模板提供了一种**重用源代码**的方法，继承或者组合提供了一种**重用对象代码**的方法

    * 实现方式：模板定义**以关键字 `template` 开始**，后**跟一个模板参数列表**。模板类型参数前必须使用关键字 `class` 或者 `typename`，在模板参数列表中这两个关键字含义相同，可互换使用。

      ```c++
      template <typename T, typename U, ...>
      ```

    * 作用：

      * **编译时检查数据类型**，保证了**类型安全**。

    * 限制：

      * 引用不能作为模板实参。

      * 与常规类成员函数不同，**类模板成员函数的声明和定义都应该放在同一个头文件中**。

      * 编译器会将模板中类型参数**标识符定义为模板声明范围内的类型名称**，不能在该范围内重新定义：【VC++ 5.0不会标记类型参数重复定义为一个错误】

        ```c++
        template <class T, int size>
        class Stack
        {
        	int T ; //error type-parameter re-defined.
        	void f()
        	{
        		char T ; //error type-parameter re-defined.
        	}
        } ;
        
        class A {} ;
        int main()
        {
        	Stack<A,10> si ;
               return 0 ;
        }
        ```

    * 函数模板：

      * 设计目的：简洁方便地**对每种类型的数据执行相同的操作**

      * 使用：当调用一个模板时，编译器用函数**实参来推断**模板实参，从而使用实参的类型来确定绑定到模板参数的类型。**故可不同加尖括号指明模板类型实参。**

        ```c++
        #include <iostream>
        using namespace std ;
        //max returns the maximum of the two elements
        template <class T>
        T max(T a, T b)
        {
        	return a > b ? a : b ;
        }
        void main()
        {
           
        	cout << "max(10, 15) = " << max(10, 15) << endl ;
        	cout << "max('k', 's') = " << max('k', 's') << endl ;
        	cout << "max(10.1, 15.2) = " << max(10.1, 15.2) << endl ;
        }
        ```

      * 常见使用场景：STL库中的算法函数

      * ```c++
        #include <iostream>
        using namespace std ;
        //max returns the maximum of the two elements
        template <class T>
        T max(T a, T b)
        {
        	return a > b ? a : b ;
        }
        ```

    * 类模板：

      * 类模板Stack：

      ```c++
      //stack.h
      #pragma once
      template <class T>
      class Stack
      {
      public:
      	Stack(int = 10) ; 
      	~Stack() { delete [] stackPtr ; }
      	int push(const T&); 
      	int pop(T&) ;  // pop an element off the stack
      	int isEmpty()const { return top == -1 ; } 
      	int isFull() const { return top == size - 1 ; } 
      private:
      	int size ;  // Number of elements on Stack
      	int top ;  
      	T* stackPtr ;  
      } ;
      
      //constructor with the default size 10
      template <class T>
      Stack<T>::Stack(int s)
      {
      	size = s > 0 && s < 1000 ? s : 10 ;  
      	top = -1 ;  // initialize stack
      	stackPtr = new T[size] ; 
      }
       // push an element onto the Stack 
      template <class T>
      int Stack<T>::push(const T& item)
      {
      	if (!isFull())
      	{
      		stackPtr[++top] = item ;
      		return 1 ;  // push successful
      	}
      	return 0 ;  // push unsuccessful
      }
      
      // pop an element off the Stack
      template <class T> 
      int Stack<T>::pop(T& popValue) 
      {
      	if (!isEmpty())
      	{
      		popValue = stackPtr[top--] ;
      		return 1 ;  // pop successful
      	}
      	return 0 ;  // pop unsuccessful
      }
      ```

      * 使用类模板：编译器**不能为类模板推断模板参数类型**，需要在使用该类模板时，在模板名后面的尖括号中指明类型。

      ```c++
      #include <iostream>
      #include "stack.h"
      using namespace std ;
      void main()
      {
      	typedef Stack<float> FloatStack ;
      	typedef Stack<int> IntStack ;
      
      	FloatStack fs(5) ;
      	float f = 1.1 ;
      	cout << "Pushing elements onto fs" << endl ;
      	while (fs.push(f))
      	{
      		cout << f << ' ' ;
      		f += 1.1 ;
      	}
      	cout << endl << "Stack Full." << endl
      	<< endl << "Popping elements from fs" << endl ;
      	while (fs.pop(f))
      		cout << f << ' ' ;
      	cout << endl << "Stack Empty" << endl ;
      	cout << endl ;
      
      	IntStack is ;
      	int i = 1.1 ;
      	cout << "Pushing elements onto is" << endl ;
      	while (is.push(i))
      	{
      		cout << i << ' ' ;
      		i += 1 ;
      	}
      	cout << endl << "Stack Full" << endl
      	<< endl << "Popping elements from is" << endl ;
      	while (is.pop(i))
      			cout << i << ' ' ;
      	cout << endl << "Stack Empty" << endl ;
      }
      ```

  * 模板实例化：

    * 编译器**识别到**显式或隐式地【类、函数】**模板实例化**时，将会根据对应模板**生成对应模板实参的类和函数的定义**，注意：编译器**不会为不需要实例化的函数、非虚成员函数、类或成员类生成定义。**

      ```c++
      template <class T>
      class Z
      {
        public:
      Z() {} ;
      ~Z() {} ;
      virtual void Test() {} //  the compiler generates a definition for X<int>::Test, even if it is not required. 如果模板实例化对应虚函数定义会自动生成
      void f(){} ;
      void g(){} ;
      } ;
      
      //max returns the maximum of the two elements
      template <class T>
      T max(T a, T b)
      {
          return a > b ? a : b ;
      }
      
      template <class T>
      void Test(T r_t)
      {
      }
      
      template <class T> class X ; // the template declared but not defined
      int main()
      {
      Z<int> zi ; //implicit instantiation generates class Z<int>
      zi.f() ;    //and generates function Z<int>::f() 
      Z<float> zf ; //implicit instantiation generates class Z<float>
      zf.g() ;      //and generates function Z<float>::g()
          
      //template class Z<int> ; //explicit instantiation of class Z<int>
      //template class Z<float> ; //explicit instantiation of 
          
      // 只是声明并不需要定义，故编译器不会为其生成定义 
      Z<int>* p_zi ; //instantiation of class Z<int> not required
      Z<float>* p_zf ; //instantiation of class Z<float> not required
          
      int I ;
      I = max(10, 15) ; //implicit instantiation of max(int, int)
      char c ;
      c = max('k', 's') ; //implicit instantiation of max(char, char)
          
      //explicit instantiation of Test(int) 注意部分编译器可能不支持此语法。。
      template void Test<int>(int) ;
      X<int> xi ; //error C2079: 'xi' uses undefined class 'X<int>' 模板必须定义
      return 0 ;
      }
      ```

    * **模板提供复用的源代码，编译器根据模板实参来生成对应类的定义**，如果模板中有static成员，模板实例化出多少种定义，就会有多少个对应static成员

      ```c++
      // 模板类 A  static变量 整个程序有几份 模板实例化出几种类定义 就有几份static变量
      template<typename T> class tempClass  {
      public:
      	static int a;
      };
      template class tempClass<int>; // explict instantiation
      template class tempClass<double>;
      // 定义不同模板实参类对应的静态变量
      int tempClass<int>::a = 5;
      int tempClass<double>::a = 6;
      
      void testStaticTemplate() {
      	std::cout << tempClass<int>::a << std::endl; // 5
      	std::cout << tempClass<double>::a << std::endl; // 6
      	std::cout << &(tempClass<int>::a) << std::endl; // 00E4A00C
      	std::cout << &(tempClass<double>::a) << std::endl;// 00E4A010
      
      	tempClass<int> Int1;
      	tempClass<int> Int2;
      	Int1.a = 4;
      	std::cout << tempClass<int>::a << std::endl; // 4
      	Int2.a = 3;
      	std::cout << tempClass<int>::a << std::endl; // 3
      }
      ```

  * 模板和友元：

    * 可以**在类模板和全局函数、另一个类的成员函数(可能是模板类)甚至整个类(可能是模板类)之间建立友谊。**下表列出了**声明类的不同类型朋友**的结果。![image-20230318171551915](../../img/image-20230318171551915.png)

  * 函数模板和类模板的区别：

    * **实例化方式**不同：**函数模板实例化由编译程序在处理函数调用时自动完成**，类模板实例化需要**在程序中显式指定**。

    * **实例化的结果**不同：函数模板实例化后是一个函数，类模板实例化后是一个类。

    * **默认参数**：**函数模板不允许有默认参数**，**类模板**在模板参数列表中**可以有默认参数**。

      * 注意：

        * **使用模板类/函数时，如果对应模板声明在头文件中，则模板定义也必须在头文件中**，不会报重定义的问题，编译器会对此进行特殊处理。

        * 编译器**不允许在特化的声明或定义中指定默认参数**。

        * 如果为任何形式参数指定默认模板参数，则规则与函数和默认参数相同。**一旦声明了默认参数，所有后续参数都必须具有默认值。**

        * C++允许**非类型模板参数**

          * 基于值的模板，参数类型已经确定，参数名也确定，但值未确定，可能有默认值，但**无法对其赋值或者修改！！**非类型模板参数类型**不能声明为浮点型**【单双精度都不行】
        
          ```c++
          template <class T = float, int elements = 100> Stack{
              ....
              T elems[elements]; // 使用非类型模板参数作为容量
              void f(){elements++; // error}
          }
          template <double d> class X; //error C2079
          template <float d> class X;

        * 编译器会将**可以解释为参数声明或类型参数的模板参数**视为**类型模板参数**。todo理解http://users.cis.fiu.edu/~weiss/Deltoid/vcstl/templates
        
          ```c++
          class T {} ;
          int i ;
          
          template <class T, T i>
          void f(T t)
          {
          	T t1 = i ; //template arguments T and i
          	::T t2 = ::i ; //globals T and i 
          } 
          
          
          
          int main()
          {
          	f('s') ; //C2783 here
          	return 0 ;
          }
          ```

    * **特化**：**函数模板只能全特化**；而**类模板可以全特化，也可以偏特化。**

    * **调用方式**不同：**函数模板**可以进行类型推导，可以**隐式调用，**也可以显式调用；**类模板只能显式调用。**

  * 可变参数模板：

    * 定义：接受**可变数目参数**的**模板函数或模板类**。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。
  * 模板参数包：表示零个或多个**模板参数**；
    * 函数参数包：表示零个或多个**函数参数**。
    * 当需要知道包中有多少元素时，可以使用 **`sizeof...` 运算符。**

    ```c++
    template <typename T, typename... Args> // Args 是模板参数包
    void foo(const T &t, const Args&... rest); // 可变参数模板，rest 是函数参数包
    ```

    * **可变参数函数通常是递归的**

  * 模板特化

    * 原因：**模板并非对任何模板实参都合适、都能实例化**，某些情况下，**通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。**

    * 模板特化：**为特定类型提供特殊定义来覆盖模板生成的代码**。**模板参数在某种特定类型下的具体实现**。分为函数模板特化和类模板特化

      函数模板特化：将函数模板中的**全部类型**进行特例化，称为函数模板特化。**函数模板不能被偏特化**。
    类模板特化：将类模板中的**部分或全部类型**进行特例化，称为类模板特化。

    * 特化分为**全特化和偏特化**：

      - 全特化：模板中的模板参数**全部特例化**。
    - 偏特化：模板中的模板参数**只确定了一部分，剩余部分需要在编译器编译时确定。**【Visual C++ 5.0不支持】

    * 说明：要**区分下函数重载与函数模板特化**
    定义函数模板的特化版本，**本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载**，函数模板特化并不影响函数匹配。

    * ```c++
      #include <iostream>
      #include <cstring>
      
      using namespace std;
      s
      // 类模板
      template <typename T, typename U>
      class A {
      private:
          T id;
          U name;
      public:
          A (T _id, U _name):id(_id), name(_name) {
              cout << "Template" << endl;
          }
      };
      
      // 类模板特化，每个模板参数都全部特例化
      template <>
      class A<int, string> {
      private:
          int id;
          string name;
      public:
          A (int _id, string _name):id(_id),name(_name) {
              cout << "Template Specialization" << endl;
          }
      };
      
      // 类模板偏特化，部分参数特化
      template <typename U>
      class A<int, U> {
      private:
          int id;
          U name;
      public:
          A (int _id, U _name):id(_id),  name(_name) {
              cout << "Partial Template Specialization" << endl;
          }
      };
      
      //max returns the maximum of the two elements
      template <class T>
      T max(T a, T b)
      {
          return a > b ? a : b ; // 对于字符串常量比较的是地址
      }
      
      // Specialization of max for cosnt char* 用于比较字符串常量 
      template <>
      const char* max(const char* a, const char* b)
      {
          return strcmp(a, b) > 0 ? a : b ;
      }
      
      int main() {
      
      /**
      模板类调用优先级：
          全
      */
      
          A<int, string> a(1, "zhangsan");     // 调用类模板特化, 即 A<int, string>
      
          A<int, int> aa(1, 2);     // 第一个参数时 int, 而第二个参数不是 string, 故调用了类模板偏特化
      
          A<string,int> aaa("zhangsan", 1);   // 第一个参数不是 int, 不符合模板特化和偏特化，故调用类模板
      	
          cout << "max(10.1, 15.2) = " << max(10.1, 15.2) << endl ; //15.2
          cout << "max(\"Aladdin\", \"Jasmine\") = " << max("Aladdin", "Jasmine") << endl ; // Jasmine
          return 0;
      }
      ```

  * 泛型编程如何实现

    * 泛型编程实现的基础：**模板**。模板是创建类或者函数的蓝图或者说公式，**编译时会转化为特定的类或者函数。**

    * 泛型编程**优缺点**：

      * **通用性强**：泛型算法是建立在**语法一致性**上，运用到的类型集是无限的/非绑定的。

      * **效率高**：**编译期能确定静态类型信息**，其效率与针对某特定数据类型而设计的算法相同。

      * **类型检查严**：**静态类型信息被完整的保存在了编译期**，在编译时可以发现更多潜在的错误。

      * **二进制复用性差**：泛型算法是建立在语法一致性上，语法是代码层面的，**语法上的约定无法体现在机器指令中**。泛型算法实现的库，其源代码基本上是必须公开的，**引用泛型中库都需要重新编译生成新的机器指令**。而传统的 C 库全是以二进制目标文件形式发布的，需要使用这些库时直接动态链接加载使用即可，不需要进行再次编译。

  * 类型萃取：

    * 定义：**类型萃取（type traits）使用模板技术来萃取类型**（包含自定义类型和内置类型）**的某些特性**，**用以判断该类型是否含有某些特性**，从而在泛型算法中来**对该类型进行特殊的处理**用来提高效率或者得到其他优化。【确定变量去除引用修饰后真正的变量类型或者CV属性】

    * 使用可参考：#include <type_traits> 其中定义了很多类型萃取常用的类模板函数，比如`is_convertible`，`is_trivially_destructible`等。

    * 原因：**模板传入的类型具有不确定性，对于需要根据针对传入的不同类型和不同特性做不同的处理时，我们可以通过类型萃取对传入的参数类型和特性进行提取。**【在编译期就根据type_traits提供的类模板函数判断true和false，进而选择性的生成你想要的code。】

    * 类型萃取使用例子：

      https://zhuanlan.zhihu.com/p/547313994
    
      iterator_traits：用来**萃取迭代器内部定义的各种类型并对外统一为相同的类型名**，如迭代器本身的类型，迭代器指向元素的类型等。
      
      具体实现是：对于迭代器为原生指针类型的有一个偏特化版本，然后如果迭代器有iterator_category属性且迭代器可转化为input_iterator或output_iterator时则有对应的偏特化版本可以萃取迭代器内部定义的各种属性。
      
    * 相关原理：

      一般是通过type_traits提供的**编译期的true和false**以及**模板特化**来实现对类型某些特性的萃取。

* 编译相关

  * include " " 和 <> 的区别
    * 查找位置：<>在**标准库头文件所在的目录中查找**，" "在**当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。**
    * 使用习惯：对于**标准库中的头文件常用** `include<文件名>`，对于**自己定义的头文件**，常用 `#include"文件名"`

* 关键字相关

  * strlen()和sizeof()区别：

    * 一个是**函数**一个是**运算符**。
    * 作用于**字符数组**时一个得到**字符串长度**，一个得到**数组长度。**【前者遇到'\0'才停止，且'\0'不计入长度】
    * **字符数组作为函数参数时**，两者分别作用于此数组一个得到**字符串长度**，一个得到**字符指针长度**。
    * 前者在**运行时计算字符串长度**，后者**在编译时计算字符数组长度**。
    * 前者**作用于字符串**，后者**既可以用于变量又可以用于类型**。

  * extern C：
    * 作用：让 C++ 编译器将 extern "C" **声明的代码当作 C 语言代码处理**，可以避免 C++ **因符号修饰导致代码不能和C语言库中的符号进行链接的问题**。
    * c和c++对同一个函数经过编译后生成的函数名是不同的，**由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中**，而不仅仅是函数名；而C语言并不支持函数重载，**因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。**如果**在c++中调用一个使用c语言编写的模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误。**
  * sizeof
    * 接受参数：**对象或表达式**
    * `sizeof(expression)` **在运行时不会对接受的表达式进行计算**，编译器**只会推导表达式的类型从而计算占用的字节大小；**
    * sizeof(1==1) 在 C 和 C++ 中的结果
      * 由于 **`C` 语言没有 `bool` 类型，用整型表示布尔型**，故返回4字节或8字节。
      * 由于 `C++` 语言有 `bool` 类型，**布尔型占 `1` 个字节**

## 并发

* **传统的C++（C++11标准之前）中并没有引入线程这个概念**，在C++11出来之前，如果我们想要**在C++中实现多线程，需要借助操作系统平台提供的API**，**比如Linux的<pthread.h>，或者windows下的<windows.h>** 。
  * C++11提供了**语言层面上的多线程**，包含在头文件<thread>中。它**解决了跨平台的问题**，提供了**管理线程、保护共享数据、线程间同步操作、原子操作等类**
  * C++11 新标准中引入了**5个头文件来支持多线程编程**![img](../../img/v2-76e5e48c9c1d60f9868452cfc9ce7d85_720w.webp)

* 多进程与多线程https://zhuanlan.zhihu.com/p/613630658

  * 多进程并发

    * 使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对**进程提供了大量的保护机制**，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。但是这也造就了多进程并发的两个缺点：

      * **在进程间的通信**，无论是使用**信号、套接字，还是文件、管道**等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。
      * **运行多个进程的开销很大**，操作系统要分配很多的资源来对这些进程进行管理。

      当多个进程并发完成同一个任务时，不可避免的是：**操作同一个数据和进程间的相互通信**，上述的两个缺点也就决定了多进程的并发并不是一个好的选择。所以就引入了多线程的并发。

  * 多线程并发

    * 多线程并发指的是在同一个进程中执行多个线程。
    * 优点：线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。
    * 缺点：由于**缺少操作系统提供的保护机制**，在**多线程共享数据及通信时**，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。

  * thread：

    * 线程创建：

    * ```c++
      1、
      // 开启线程，调用：thread_fun(100)
      std::thread myThread ( thread_fun, 100);
      //函数形式为void thread_fun(int x)
      myThread.join();
      //同一个函数可以代码复用，创建多个线程
      2、
      std::thread myThread ( thread_fun(100));
      myThread.join();
      //函数形式为void thread_fun(int x)
      //同一个函数可以代码复用，创建多个线程
      3、
      std::thread (thread_fun,1).detach();
      //直接创建线程，没有名字
      //函数形式为void thread_fun(int x)
      ```

    * join与detack方式：

      当线程启动后，一定要在和线程相关联的thread销毁前，**确定以何种方式等待线程执行结束。**

      * detach方式，启动的线程自主在后台运行，主线程不会等待子线程结束。**如果主线程运行结束，程序则结束。**
      * join方式，等待启动的线程完成，才会继续往下执行。

      ```c++
      // 可以使用joinable判断是join模式还是detach模式。
      if (myThread.joinable()) foo.join();
      ```

    * this_thread，一个类，它有4个功能函数，一般在某个线程内调用：

      | 函数        | 使用                                                  | 说明                       |
      | ----------- | ----------------------------------------------------- | -------------------------- |
      | get_id      | std::this_thread::get_id()                            | 获取线程id                 |
      | yield       | std::this_thread::yield()                             | 放弃线程执行，回到就绪状态 |
      | sleep_for   | std::this_thread::sleep_for(std::chrono::seconds(1)); | 暂停1秒                    |
      | sleep_until | 如下                                                  | 一分钟后执行吗，如下       |

    ```c++
    using std::chrono::system_clock;
    std::time_t tt = system_clock::to_time_t(system_clock::now());
    struct std::tm * ptm = std::localtime(&tt);
    cout << "Waiting for the next minute to begin...\n";
    ++ptm->tm_min; //加一分钟
    ptm->tm_sec = 0; //秒数设置为0//暂停执行，到下一整分执行
    this_thread::sleep_until(system_clock::from_time_t(mktime(ptm)));
    ```

  * mutex：

    * mutex头文件主要声明了与**互斥量(mutex)相关的类。mutex提供了4种互斥类型**

      | 类型                       | 说明                |
      | -------------------------- | ------------------- |
      | std::mutex                 | 最基本的 Mutex 类。 |
      | std::recursive_mutex       | 递归 Mutex 类。     |
      | std::time_mutex            | 定时 Mutex 类。     |
      | std::recursive_timed_mutex | 定时递归 Mutex 类。 |

    * std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提**供了独占所有权的特性**——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以**递归地对互斥量对象上锁**。

    * lock与unlock

      * mutex常用操作：

        - lock()：资源上锁
        - unlock()：解锁资源
        - trylock()：查看是否上锁，它有下列3种类情况：

        （1）未上锁返回false，并锁住；

        （2）其他线程已经上锁，返回true；

        （3）同一个线程已经对它上锁，将会产生死锁。
        
      * 在实际编写代码的过程中，最好不去直接调用成员函数lock， 因为调用成员函数就需要**在每个临界区的出口处调用unlock**， C++11 还为互斥量提供了一个 RAII 语法的模板类 `std::lock_guard`。 **RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。**

    * lock_guard

      * 创建lock_guard对象时，它将**尝试获取提供给它的互斥锁的所有权。**当**控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量**。lock_guard的特点：
        - 创建即加锁，作用域结束自动析构并解锁，无需手工解锁
        - 不能中途解锁，必须等作用域结束才解锁
        - 不能复制

    * unique_lock

      * unique_lock 是 lock_guard 的**升级加强版**，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更加灵活方便，能够应对更复杂的锁定需要。unique_lock的特点：
        - 创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定
        - 可以**随时加锁解锁**
        - 作用域规则同 lock_grard，析构时自动释放锁
        - 不可复制，可移动
        - **条件变量需要该类型的锁作为参数（此时必须使用unique_lock）**

  * atomic：

    * **原子类型atomic<>**

      * 原子操作指“不可分割的操作”，互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量(操作变量时加锁防止他人干扰)。【将一个 **原子类型读写操作从一组指令**，**最小化到单个 CPU 指令**】

      *  std::atomic<>是一个模板类，使用该模板类实例化的对象，**提供了一些保证原子性的成员函数来实现共享数据的常用操作。**

      * std::atomic<>用来定义一个自动加锁解锁的共享变量（“定义”“变量”用词在这里是不准确的，但是更加贴切它的实际功能），**供多个线程访问而不发生冲突。**

      * ```c++
        //原子类型的简单使用
        std::atomic<bool> b(true);
        b=false;
        ```

      * std::atomic<>对象提供了常见的原子操作（通过调用成员函数实现对数据的原子操作）： store是原子写操作，load是原子读操作。exchange是于两个数值进行交换的原子操作。 **即使使用了std::atomic<>，也要注意执行的操作是否支持原子性**。一般针对++，–，+=，-=，&=，|=，^=是支持的，**这些原子操作是通过在std::atomic<>对象内部进行运算符重载实现的。**
      
      * 并非所有的类型都能提供原子操作，这是因为**原子操作的可行性取决于具体的 CPU 架构**，以及所实例化的**类型结构是否能够满足该 CPU 架构对内存对齐 条件的要求**，因而我们总是可以通过 `std::atomic<T>::is_lock_free` **来检查该原子类型是否需支持原子操作**
      
      * ```c++
        #include <atomic>
        #include <iostream>
        
        struct A {
            float x;
            int y;
            long long z;
        };
        
        int main() {
            std::atomic<A> a;
            std::cout << std::boolalpha << a.is_lock_free() << std::endl;
            return 0;
        }
        ```
      
      * 

  * condition_variable:

    * condition_variable头文件有两个variable类，一个是condition_variable，另一个是condition_variable_any。**condition_variable必须结合unique_lock使用。condition_variable_any可以使用任何的锁。**

    * condition_variable条件变量**可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止。**condition_variable是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应的condition_variable对象，调用对象相应的函数来实现上面的功能。

      | 类型               | 说明                                         |
      | ------------------ | -------------------------------------------- |
      | condition_variable | 构建对象                                     |
      | 析构               | 删除                                         |
      | wait               | Wait until notified                          |
      | wait_for           | Wait for timeout or until notified           |
      | wait_until         | Wait until notified or time point            |
      | notify_one         | 解锁一个线程，如果有多个，则未知哪个线程执行 |
      | notify_all         | 解锁所有线程                                 |
      | cv_status          | 这是一个类，表示variable 的状态，如下所示    |

    * ```c++
      enum class cv_status { no_timeout, timeout };
      ```

    * wair

    * waif_for

  * future：

    * 该头文件提供了**异步线程相关的类和接口**，std::future提供了一个**访问异步操作结果**的途径。

    * **async与future：**

      * std::async是一个**函数模板**，用来**启动一个异步任务**，它返回一个std::future类模板对象，调用std::future对象的**get()成员函数**时，**主线程会被阻塞直到异步线程执行结束**，并**把返回结果传递给std::future**，即通过FutureObject.get()获取函数返回值。

    * **packaged_task：**

      * **封装任何可调用类型**，存储其返回值以进行异步获取

      * 常作为Callable类型传入thread进行构造执行

      * packaged_task<F>::get_future()：获取任务关联的future

      * ```c++
        #include <iostream>
        #include <future>
        #include <thread>
        
        int main() {
            // 将一个返回值为7的 lambda 表达式封装到 task 中
            // std::packaged_task 的模板参数为要封装函数的类型
            std::packaged_task<int()> task([](){return 7;});
            // 获得 task 的期物
            std::future<int> result = task.get_future(); // 在一个线程中执行 task
            std::thread(std::move(task)).detach();
            std::cout << "waiting...";
            result.wait(); // 在此设置屏障，阻塞到期物的完成
            // 输出执行结果
            std::cout << "done!" << std:: endl << "future result is "
                      << result.get() << std::endl;
            return 0;
        }
        ```

      * 

    * **promise与future：**

      * **存储一个值以进行异步获取**

      * promise<T>::set_value(T)：存储值，调用完后关联的future就绪

    * **shared_future**

      * std::future的get()成员函数是**转移数据所有权**;std::shared_future的get()成员函数是**复制数据**。

        因此： **future对象的get()只能调用一次**；无法实现多个线程等待同一个异步线程，**一旦其中一个线程获取了异步线程的返回值，其他线程就无法再次获取**。 **std::shared_future对象的get()可以调用多次**；可以实现**多个线程等待同一个异步线程，每个线程都可以获取异步线程的返回值。**![image-20240111113107520](../../img/image-20240111113107520.png)

  * std::thread对比于pthread

    * 优点：
      * 简单，易用
      * 跨平台，**pthread只能用在POSIX系统上（其他系统有其独立的thread实现）**
      * 提供了更多高级功能，比如future
      * 更加C++（跟匿名函数，std::bind，RAII等C++特性更好的集成）

    * 缺点：
      * **没有RWlock**。有一个类似的**shared_mutex**，不过它属于**C++14**,你的编译器很有可能不支持。

      * **操作线程和Mutex等的API较少**。毕竟为了跨平台，只能选取各原生实现的子集。如果你需要设置某些属性，需要通过API调用返回原生平台上的对应对象，再对返回的对象进行操作。

* volatile

  * 定义：提醒编译器它后面所**定义的变量随时都有可能改变**，因此**编译后的程序每次需要存储或读取这个变量的时候，都会直接从内存中读取数据，而不是从寄存器中取出**。
  * 作用：
    * **只能保证赋值原子性**，复合操作不能保证；
    * 告诉编译器**不进行指令重排**，以**避免过度优化**；
    * 保证**内存可见性**。
  * 使用场景：
    * **多线程环境中，为了保证变量变化可见，即保证内存可见性，常对共享变量加volatile修饰。**
  * 和const的搭配
    * `volatile` 关键字和 `const` 关键字可以同时使用，某种类型可以既是 `volatile` 又是 `const` ，同时具有二者的属性。
  
* 内存顺序

### 互斥锁的底层原理

* 锁实质是一块被多个线程共享的内存空间，需要保证多个线程对这块内存空间的修改是原子且互斥的，就需要提供某种特殊的指令来保证。
* CPU提供了原子的CAS（Compare and Swap）操作来对这块内存空间进行操作，这些原子操作由多个机器指令组成，通过**多个指令能实现应用层所提供的原子操作即lockfree**【包含spinlock，不存在context switch】
  * lockfree相比mutex的优点：
    * 临界区很小的时候，换成lockfree性能通常会提高很多。
    * 使用lockfree可以避免死锁/活锁
  * 缺点：
    * 因为ABA problem、memory order等问题，使得lockfree比mutex难实现得多。
  * 除非性能瓶颈已经确定，否则还是乖乖用mutex+condvar，等到以后出bug了就知道mutex的好了。如果一定要换lockfree，请一定要先profile，profile，profile！请确保时间花在刀刃上
* 为了避免spinlock**引起的CPU资源空耗**，加入了block wait【存在context switch】，即形成了Mutex【互斥锁】
  * 先spin，拿不到锁再block wait，还是直接block wait，这是具体实现的问题

### C++中保证线程安全的方式

* **互斥量(Mutex)**：使用互斥锁可以保护**临界区（一段代码或操作需要保证同一时刻只能由一个线程执行的区域）**，确保**在同一时刻只有一个线程可以访问共享资源**。常见的互斥锁包括 `std::mutex`、`std::recursive_mutex` 等。
* **条件变量(Conditon Variable)**：条件变量用于**线程间的通信**，允许线程**等待某个条件成立后**再继续执行。常**与互斥锁配合使用**，例如 `std::condition_variable`。
* **原子操作(Atomic Operation)**：原子操作可以**确保某个操作在多线程环境下是原子性的，不会被中断**。C++ 提供了一系列的原子操作类型，如 `std::atomic`，用于操作原子类型的数据。
* **读写锁(Read-Write Lock)**：**对于读多写少的场景，可以使用读写锁来提高并发性能。**读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。在C++中，可以使用 `std::shared_mutex`（C++17引入）来实现读写锁。
* **线程局部存储(Thread-Local Storage)**：每个线程有自己独立的存储空间，可以避免多个线程访问同一全局变量而导致的条件竞争。**可以使用 `thread_local` 关键字定义线程局部变量。**
* **使用锁的RAII封装**：使用 RAII（资源获取即初始化）技术可以确保**在作用域结束时自动释放锁，避免忘记释放锁而导致的死锁等问题。**可以使用 `std::lock_guard`、`std::unique_lock` 等**封装互斥锁**。

### 死锁的产生以及避免

* 死锁（Deadlock）：是在**多个进程或线程之间互相持有对方所需要的资源而无法继续执行的一种状态**，是多线程或多进程并发编程中常见的问题。
* 产生的条件：
  * **资源互斥**：至少有一个资源是不可共享的，即一次只能被一个进程或线程占用。
  * **持有和等待**：进程或线程持有至少一个资源，并在等待获取其他进程或线程占用的资源。
  * **不可抢占**：已经分配给一个进程或线程的资源不能被强制性地抢占，只能由持有它的进程或线程释放。
  * **循环等待**：存在一个进程或线程的**资源等待链**，使得每个进程或线程都在等待下一个进程或线程所持有的资源。

* 避免方法：
  * **资源一次性分配**：尽量避免使用不可共享的资源，或者在使用资源时尽量降低资源的独占性。
  * **资源有序分配**：规定所有的资源**必须按照某个全局统一的顺序进行申请**，**释放资源时按相反的顺序释放。**
  * **资源预先分配**：在系统运行之前**就确定每个进程或线程所需要的全部资源**，并根据资源的使用情况进行分配，避**免在运行过程中动态地分配资源。

* 解决方法：破坏死锁产生的条件
  * **死锁检测与解除**：通过系统监控和检测，一旦发现死锁的存在就立即进行解除。
  * **超时机制**：设置一个超时时间，在规定时间内未能获取所需资源，则放弃对资源的请求，释放已经持有的资源，从而避免死锁。
  * **资源剥夺**：当发现系统出现死锁时，可以强制性地抢占某些进程或线程所持有的资源，以解除死锁。


### 加锁前需考虑什么

* **并发访问情况**：需要考虑在多个线程同时访问某个共享资源时可能出现的情况，如**读写冲突、数据竞争**等。
* **加锁粒度**：需要考虑在哪些代码段需要加锁以及锁的粒度。锁的粒度过细会导致**频繁加锁解锁**，影响性能；而锁的粒度过粗则可能导致**锁竞争，降低并发性能。**
* **锁的选择**：需要根据**实际情况选择合适的锁**，如互斥锁、读写锁、自旋锁等，以及选择**合适的锁策略**，如短期互斥、长期等待等。
* **锁的生命周期**：需要**考虑锁的生命周期**，确保锁的加锁和解锁操作成对出现，**避免死锁等问题**。
* **锁的可重入性**：如果一个线程在持有锁的情况下再次尝试获取这个锁，不会造成死锁或其他异常情况，这种情况称为锁的可重入性。
* **锁的性能影响**：加锁会引入额外的开销，需要**评估加锁对程序性能的影响**，尤其是在高并发场景下。
* **资源管理**：在使用锁的过程中需要**注意资源的管理**，如避免内存泄漏、资源竞争等问题。
* **异常处理**：需要考虑在**加锁过程中可能发生的异常情况**，确保异常安全性。



## IO相关

* 加快IO操作的方法：

  ```c++
  // 关闭同步，并解除输入/输出流之间的绑定
  static const auto io_sync_off = []()
  {
      // turn off sync
      std::ios::sync_with_stdio(false); // 是否兼容stdio
      // untie in/out streams
      std::cin.tie(nullptr);
      return nullptr;
  }();
  ```

  * C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将**输出流**绑到了一起。**如果未关闭同步，C++的流本身并没有缓冲，每个C++流的操作都是直接与C的流缓冲进行交互**。**如果关闭了同步，则每个C++流操作都有自己的缓冲区，这在某些情况下会极大地加速流操作，但是就不是线程安全的了，且此时不能与C的IO函数混用**。【iostream在编译的时候，数据类型就确定了，数据和文本的转换很直接。而scanf/printf这些，%d%f这些都是要运行期动态判断的。】
  * std::cin与std::cout也有绑定，导致**每次std::cout执行后并在执行std::cin时都会刷新输出缓冲区**，也就是说**每次使用std::cin进行数据输入时，都会调用一次std::cout.flush()函数**，对缓冲区进行刷新。解除同步能够进一步加快IO速度：std::cin.tie()。
  
* 格式化输出函数：

  * 


## 编译器相关

* GCC编译器

  http://c.biancheng.net/view/7936.html

  * 其支持对多种编程语言的编译[Go、Objective-C，Objective-C ++，Fortran，Ada，Java, C， C++，D 和 BRIG]

  * gcc命令可以编译相应语言的代码【根据程序文件后缀名，自行判断语言类别】

    * 编译执行C++程序时，单纯的gcc命令是无法进行库文件链接的，需手动添加 -lstdc++ -shared-libgcc 选项，表示 **gcc 在编译 C++ 程序时可以链接必要的 C++ 标准库**

  * g++命令，一律按C++代码方式进行编译

    * 可以认为，g++ 指令就等同于`gcc -xc++ -lstdc++ -shared-libgcc`指令

    

* C 和 C++如何互调

  https://zhuanlan.zhihu.com/p/114669161

  * C++程序中调用C库：

    * 问题：C语言中没有函数重载，故**以C代码格式编译后函数对应的符号表示与函数参数列表无关**，无C++不同，故不能直接调用接口。**直接调用接口会提示找不到符号表示**，因为**以C++代码格式编译后调用函数的符号与函数参数列表有关。**

    * 可在调用文件头部，进行声明通知编译器以C代码格式生成相应函数的符号表，这样就能**在链接时找到相应符号表示**了，即调用C库成功。

      ```c++
      extern "C"{
          void add(int, int);
      }
      ```

  * C程序如何调用C++库：

    * 原因类似上方

    * C程序使用C++库，这时是需要在编译器C++前**告诉编译器以C代码格式生成调用函数的符号表示**，便于后续C程序链接C++库时找到相应符号表示。

      ```c++
      #include "robot_c_api.h"
      #include "robot.h"
      
      #ifdef __cplusplus
      extern "C" {
      #endif
      
      // 因为我们将使用C++的编译方式，用g++编译器来编译 robot_c_api.cpp 这个文件，
      // 所以在这个文件中我们可以用C++代码去定义函数 void Robot_sayHi(const char *name)（在函数中使用C++的类 Robot），
      // 最后我们用 extern "C" 来告诉g++编译器，不要对 Robot_sayHi(const char *name) 函数进行name mangling
      // 这样最终生成的动态链接库中，函数 Robot_sayHi(const char *name) 将生成 C 编译器的符号表示。
      
      void Robot_sayHi(const char *name)
      {
          Robot robot(name);
          robot.sayHi();
      }
      
      #ifdef __cplusplus
      }
      #endif
      ```

* 头文件和源文件相关

  * 头文件后缀选择：如果 `header file` 中涉及到了任何 `c++` 的语法, 那么这个头文件就应该以 `.hpp` 为后缀, 否则都已 `.h` 为后缀。
  * 理论上来说 `implementation file` 与 `header file` 里的内容, 只要是 c++ 语言所支持的, 无论写什么都可以的
  * 编译是以 `implementation file` 为单位的， `implementation file` 包含的 `header file` 编译成`object`文件的一部分。
  * 为何一般都在 `header file` 中进行函数, 变量声明, 宏声明, 结构体声明呢? 而在 `implementation file` 中去进行变量定义, 函数实现呢?
    * 在头文件中进行声明可以避免重复手动声明，只需引入相应的头文件即可。
    * 如果在头文件进行定义，如实现一个全局函数，这时有多个源文件引用了此头文件，那么编译链接时会发现存在多个相同的函数，就会报重复定义的错误。
  * 头文件如何关联源文件
    * `#include` 预处理就是完成了一个 **复制并插入代码** 的工作.实际上是**引入相关声明, 使得编译可以通过**, 程序并不关心实现是在哪里, 是怎么实现的.  **源文件编译后成生成 `obj file`, 在此文件中, 这些函数和变量就视作一个个符号.** 
    * 程序**链接时才会寻找头文件的实现**，链接时会**在每个 `.o` 或 `.obj` 文件中都去找一下所需要的实现**, 而不是只在某个文件中找或者说找到一个就不找了. 因此, 如果在几个不同文件中实现了同一个函数, 或者定义了同一个全局变量, 链接的时候就会提示`redefined`.
  * 声明和定义：
    * 根据 cpp 标准的规定, **一个变量声明必须满足两个条件**, 否则就是定义:
      * **必须使用 extern;**
      * **不能为变量赋予初始值;**
    * 定义变量和声明变量的区别在于**定义会产生内存分配的操作**, 是汇编阶段的概念; 而**声明则只是标示所修饰的变量或函数的可能位于其他模块.**
  
* **名字修饰（Name Mangling）**是一种在`编译`过程中，将函数、变量的名称重新改编的机制，简单来说就是[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)为了**区分各个函数，将函数通过一定算法，重新修饰为一个全局唯一的名称**。【**编译过程中生成的符号表**】

  * 为什么C语言不支持函数重载？
    * C语言的**名字修饰规则非常简单**，只是在函数名字**前面添加了下划线。**
    * C++要支持函数重载，命名空间等，使得其修饰规则比较复杂，被重新修饰后的名字中包含了函数的名字以及参数类型。这就是为什么函数重载中几个同名函数要求其参数列表不同的原因。只要参数列表不同，编译器在编译时通过对函数名字进行重新修饰，**将参数类型包含在最终的名字中，就可保证名字在底层的全局唯一性。**

* C++ 标志（C++ flags）是**编译器和链接器用来控制编译和链接过程的选项和参数**。它们允许开发人员指定一系列配置选项，以影响代码的编译、链接和执行行为。以下是一些常见的 C++ 标志及其作用：

1. **编译器标志（Compiler Flags）**：
   - `-std=<标准>`: 指定使用的 C++ 标准版本，如 `-std=c++11`、`-std=c++14`、`-std=c++17` 等。
   - `-Wall`, `-Wextra`: 启用警告信息，其中 `-Wall` 启用基本警告，`-Wextra` 启用额外的警告。
   - `-O<级别>`: 启用优化级别，如 `-O0`（无优化）、`-O1`、`-O2`、`-O3`。
   - `-g`: 生成用于调试的符号信息。
   - `-I<目录>`: 添加包含文件搜索路径。
   - `-D<宏>`: 定义预处理器宏，如 `-DDEBUG`。
   - `-U<宏>`: 取消预定义的宏，如 `-UDEBUG`。
   - `-f<选项>`: 启用或禁用特定的编译器特性，如 `-fno-exceptions` 禁用 C++ 异常处理。
2. **链接器标志（Linker Flags）**：
   - `-l<库名>`: 指定要链接的库，如 `-lm`（链接数学库）。
   - `-L<库目录>`: 指定库文件的搜索路径。
   - `-static`: 强制使用静态链接，而不是动态链接。
   - `-shared`: 创建共享库。
   - `-Wl,<选项>`: 将 `<选项>` 传递给链接器。
   - `-pthread`: 链接 POSIX 线程库。

这些标志的作用是**影响编译器和链接器的行为**，以满足特定的需求，比如启用特定的语言特性、优化代码、调试程序，以及链接外部库等。在使用这些标志时，开发人员可以根据项目的要求进行调整，以实现最佳的编译和链接效果。

1. **编译选项**：
   - **作用范围**：编译选项是用于控制编译器在编译源代码时的行为的设置。这些选项可以影响编译器如何处理代码、生成何种类型的目标文件等。
   - **示例**：优化级别（如 `-O2`）、警告设置（如 `-Wall`）、指定 C++ 标准（如 `-std=c++11`）等。
2. **C++标志**（或称编译器标志）：
   - **作用范围**：C++标志是传递给编译器、链接器或预处理器的特定标志，用于控制编译、链接和预处理过程中的行为和功能。
   - **示例**：添加头文件搜索路径（如 `-I<dir>`）、定义预处理器宏（如 `-DDEBUG`）、链接特定库（如 `-l<library>`）等。

虽然两者都用于配置编译和链接过程中的行为，**但编译选项更关注编译器自身的行为**，而**C++标志更广泛地涵盖了编译器、链接器和预处理器等多个工具的设置。**它们都是为了让开发者能够根据需求对编译和链接的过程进行更精细的控制和配置。

## 其他

* 正则表达式 https://github.com/ziishaned/learn-regex
  * **正则表达式（ Regular expression）是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子。**
  * 元字符：元字符不代表他们本身的字面意思，他们都有特殊的含义。![image-20230308121245889](../../img/image-20230308121245889.png)
    * [ ]：字符集，内部可使用连字符来指定字符集范围 如[a-z]
    * 重复次数元字符：
      * *：大于等于0
      * +：大于等于1
      * ?：0或1次
    * { }：量词，限定一个或一组字符可以重复出现的次数。
    * 锚点：匹配指定开头或结尾的字符串就要使用到锚点
      * ^：指定开头
      * $：指定结尾

* 浮点数的比较

  * 在实际编程中，我们通常**不建议直接比较浮点数是否相等**，而是使**用一个小的容忍度（tolerance）来检查它们的差异**是否**在可接受范围内**

    ```c++
    bool areEqual(float x, float y, float tolerance = 1e-5) {
        return std::abs(x - y) < tolerance;
    }
    ```

  * 在浮点数计算中，**由于浮点数的有限精度表示**，可能会导致**数学等式中的两边在计算机中的表示略有不同。**浮点数的**精度问题导致的舍入误差。**

## Linux系统编程

* Linux基本指令【文件系统、shell脚本】

* 开发工具

  * gcc
  * gdb
  * make

* 系统编程 https://www.zhihu.com/column/LinuxSystemProgram

  * 多进程

    * 信号

      * 定义：是进程之间通信的一种方式，用以**通知目标进程某个状态的改变或系统异常，**但不能给进程传递任何数据。它是在软件层面对中断机制的模拟，是一种异步通信的方式。

      * 类型：

        | 信号名      | 信号值 | 默认处理动作 | 发出信号的原因                                      |
        | ----------- | ------ | ------------ | --------------------------------------------------- |
        | SIGHUP      | 1      | A            | 终端挂起或者控制进程终止                            |
        | **SIGINT**  | **2**  | **A**        | **键盘中断Ctrl+c**                                  |
        | SIGQUIT     | 3      | C            | 键盘的退出键被按下                                  |
        | SIGILL      | 4      | C            | 非法指令                                            |
        | SIGABRT     | 6      | C            | 由abort(3)发出的退出指令                            |
        | SIGFPE      | 8      | C            | 浮点异常                                            |
        | **SIGKILL** | **9**  | **AEF**      | **采用kill -9 进程编号 强制杀死程序。**             |
        | SIGSEGV     | 11     | C            | 无效的内存引用                                      |
        | SIGPIPE     | 13     | A            | 管道破裂，写一个没有读端口的管道。                  |
        | **SIGALRM** | **14** | **A**        | **由alarm(2)发出的信号**                            |
        | **SIGTERM** | **15** | **A**        | **采用“kill 进程编号”或“killall 程序名”通知程序。** |
        | **SIGUSR1** | **10** | **A**        | **用户自定义信号1**                                 |
        | **SIGUSR2** | **12** | **A**        | **用户自定义信号2**                                 |
        | **SIGCHLD** | **17** | **B**        | **子进程结束信号**                                  |
        | SIGCONT     | 18     |              | 进程继续（曾被停止的进程）                          |
        | SIGSTOP     | 19     | DEF          | 终止进程                                            |
        | SIGTSTP     | 20     | D            | 控制终端（tty）上按下停止键                         |
        | SIGTTIN     | 21     | D            | 后台进程企图从控制终端读                            |
        | SIGTTOU     | 22     | D            | 后台进程企图从控制终端写                            |

      * 信号的几种**默认处理动作**：

        - A 缺省的动作是终止进程
        - B 缺省的动作是忽略此信号，将该信号丢失，不做处理
        - C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。
        - D 缺省的动作是停止进程，进入停止状态的进程还能继续运行，一般在调试阶段。
        - E 信号不能捕获
        - F 信号不能被忽略

      * 进程**对信号的处理方法**有3种：

        * 对信号的处理采用系统默认操作，大部分的信号的默认操作是终止操作
        * 设置**中断的处理函数**，收到信号后，**由该函数处理**
        * 忽略某个信号，对该信号不作任何处理

      * **signal函数**可以设置进程对信号的处理方式。

        * ```c++
          #include <csignal>
          sighandler_t signal(int signum,sighandler_t handler);
          ```

        * 参数signum表示信号的编号。

        * 参数handler表示信号的处理方式，有三种方式：

          - SIG_DFL 恢复参数signum所指信号的处理方式为默认。
          - 一个自定义的处理信号的函数，信号的编号为这个函数的参数。
          - SIG_IGN 忽略参数signum所指的信号。

      * **信号作用**

        * 向服务程序发送一个信号，**服务程序接受到这个信号后，调用响应的处理函数，完成善后工作，程序就可以完美的退出了。**
        * 向进程发送0的信号，可以检测进程是否活着。

      * **发送信号**

        * **向当前进程发送信号**：

          * ```c++
            #include <csignal>
            int raise (int sig);
            ```

          * Returns zero if successful, and a value different from zero otherwise.

        * Linux操作系统提供了`kill`和`killall`命令向程序发送信号，C语言**也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。**

          * ```c++
            #include <csignal>
            int kill(pid_t pid,int sig);
            ```

          * kill函数将**参数sig指定的信号给参数pid指定的进程。**

          * **参数pid**的几种情况;

            - pid>0 将**信号传给进程为pid的进程**
            - pid=0 将**信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号**，注意，**发送信号者进程也会收到自己发出的信号。**
            - pid=-1 **将信号广播传送给系统内所有的进程**，例如系统关机时，会向所有的登录窗口广播关机信息。

            **sig**：准备发送的**信号代码**，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。

            **返回值说明**： 成功执行时，返回0；失败返回-1，error被设为以下的某个值。

            - EINVAL：指定的信号码无效（参数 sig 不合法）。
            - EPERM：权限不够无法传送信号给指定进程。
            - ESRCH：参数 pid 所指定的进程或进程组不存在。

    * **exec函数族**

      * 提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来**取代原调用进程的数据段、代码段和堆栈段**，在执行完之后，**原调用进程的内容除了进程号外**，其他全部被新的进程替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。
  
      * ```c++
        #include <unistd.h>
        
        int execl(const char *path, const char *arg, ...);
        int execlp(const char *file, const char *arg, ...);
        int execle(const char *path, const char *arg, ..., char * const envp[]);
        int execv(const char *path, char *const argv[]);
        int execvp(const char *file, char *const argv[]);
        int execvpe(const char *file, char *const argv[], char *const envp[]);
        
        /*
        参数说明：
        path：要执行的程序路径。可以是绝对路径或者是相对路径。在execv、execve、execl和execle这4个函数中，使用带路径名的文件名作为参数。
        file：要执行的程序名称。如果该参数中包含“/”字符，则视为路径名直接执行；否则视为单独的文件名，系统将根据PATH环境变量指定的路径顺序搜索指定的文件。
        argv：命令行参数的矢量数组。
        envp：带有该参数的exec函数可以在调用时指定一个环境变量数组。其他不带该参数的exec函数则使用调用进程的环境变量。
        arg：程序的第0个参数，即程序名自身。相当于argv[O]。
        …：命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。注意：在使用此类函数时，在所有命令行参数的最后应该增加一个空的参数项(NULL)，表明命令行参数结束。
        返回值：-1表明调用exec失败，无返回表明调用成功。
        */
        ```
  
      * 单独使用没有意义,一般 是和fork/ vfork 连用。 用fork/ vfork **产生子进程，然后用exec替代**
  
    * linux进程：
  
      * Linux**不提供创建进程的调用**，故**父进程创建子进程都是克隆自己产生新进程**，**除了系统引导时内核创建的进程外**所有的**进程都必须由另一个进程创建**。
      * 可以在系统中挑一个进程，通过不断**追溯祖先进程**，可以发现，**所有的进程的祖先进程都是1号或2号进程**。
      * 0、1、2号进程：
        * idle进程：系统**创建的第一个进程**，**加载系统**【启动1、2号进程】
        * systemd进程：系统初始化，**是所有其他用户进程的祖先，早期为init进程**【**所有用户进程的祖先**】
        * kthteadd进程：负责所有内核线程的调度和管理

    * **fork**：是UNIX或类UNIX中的分叉函数，fork函数将运行着的程序分成2个（几乎）完全一样的进程，**每个进程都启动一个从代码的同一位置开始执行的线程**。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。

      * pid_t fork(void); //void代表没有任何形式参数 
      * 子进程获得了父进程的数据空间、堆和栈的副本，**不是共享**
      * 父进程中打开的文件描述符也被复制到子进程中
      * 除了0号进程（系统创建的）之外， linux系统中的进程都是由其他进程创建的。**创建新进程的进程，即调⽤fork函数的**
        **进程为⽗进程，新建的进程为⼦进程**。  
      * 对于父进程，fork返回子进程的pid；对于子进程，fork返回0；出错，fork返回-1
      * 基于写时复制的原理。
  
      ```c++
      #include <unistd.h>
      #include<sys/types.h>
      pid_t pid=fork();
      if(pid < 0){
      //失败，⼀般是该⽤户的进程数达到限制或者内存被⽤光了
      ........
      }
      else if(pid == 0){
      //⼦进程执⾏的代码
      ......
      }
      else{
      //⽗进程执⾏的代码
      .........
      }
      ```
  
      * ![img](../../img/v2-5735fafe4cdec28013bd9b9ba52cbcdb_720w.webp)
      * 子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。**父子进程间共享的存储空间只有代码段。**
      * fork出错的原因：
        * 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
  
        * 系统内存不足，这时errno的值被设置为ENOMEM。
  
    * **vfork**
  
      * fork要拷贝父进程的进程环境；而vfork则**不需要完全拷贝父进程的进程环境**，在子进程没有调用exec和exit之前，**子进程与父进程共享进程环境**，相当于线程的概念，**此时父进程阻塞等待。**
      * vfork**保证子进程先运行**，在它**调用exec或exit之后父进程才可能被调度运行**。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
      * 出现背景：
        * 以前的fork后调用exec带来的开销：当进程调用exec函数时，**一个新程序替换了当前进程的数据段、代码段和堆栈段**。这样，**前面的拷贝工作**就是**白费力气**了
        * vfork并**不复制父进程的进程环境**，子进程在父进程的地址空间中运行，所以子进程不能进行写操作，子进程执行了exec或者exit后，子进程重新读取数据段、代码段和堆栈段，**相比fork减少了从父进程拷贝数据段、代码段和堆栈段的开销**。
  
    * **getpid()\getppid()**
  
      * ```c++
        // 分别可以获取当前进程的PID和当前进程父进程的PID。
        #include <unistd.h>
        pid_t getpid(void);
        pid_t getppid(void);
        pid_t getpgid(pid_t pid); // 获得进程的进程组id
        int setpgid(pid_t pid,pid_t pgid); // 设置进程的进程组id 一个进程只能设置自己或者其子进程的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。
        ```
  
    * **wait()和waitpid()**
  
      * 孤儿进程：**父进程先于子进终止**，子进程沦为“孤儿进程”，子进程h会被systemd接管，子进程退出后1号进程会回收其占用的相关资源，孤儿进程**对系统没有危害**。
  
      * 僵尸进程：**子进程终止，父进程尚未对子进程资源【pcb】进行回收**，在此期间，子进程为“僵尸进程”。kill 对其无效。子进程的**PCB资源会残留在内核中**，浪费内存资源。
  
      * 所以在子进程终止之后，**父进程应当承担回收子进程的责任，否则就可能产生孤儿进程和僵尸进程。**
  
      * 可以在父进程中**使用`wait()`或`waitpid()`来对子进程进行回收。**
  
      * ```c++
        #include <sys/wait.h>
        // 参数为一个传出参数，表示回收子进程的状态
        // 可传入NULL，表示不关心子进程终止状态
        pid_t wait(int *wstatus);
        // 参数1指定要回收的子进程，参数3可设置WNOHANG非阻塞
        pid_t waitpid(pid_t pid, int *wstatus, int options);
        ```
  
      * `wait()`函数将**阻塞**地回收**任意一个子进程**；执行成功时将返回回收进程的PID，失败返回-1；**通过传出参数`wstatus`可以获得子进程终止状态。**
  
        * 获取**子进程正常终止值**：`WIFEXITED(status)`为真的话，可调用 `WEXITSTATUS(status)`获得子进程的退出值。
        * 获取导致**子进程异常终止信号**：`WIFSIGNALED(status)`为真的话，可调用`WTERMSIG(status)`得到导致子进程异常终止的信号编号。
  
      * `waitpid()`则可以**指定特定子进程**进行回收，同时也可以设置非阻塞。返回值大于0时表示成功回收子进程，返回值就是对应PID；**返回值为0时，表示设置了非阻塞且子进程未结束未能回收**；返回值为-1时表程序执行出错。
  
      * 注意无论**这两个函数一次都只能回收一个子进程**，需要**回收多个子进程需要使用循环。**
  
    * **进程通信**
  
      * Unix系统中实现进程间通信的方法很多，而且不幸的是，极少方法能在所有的Unix系统中进行移植（唯一一种是半双工的管道，这也是最原始的一种通信方式）。L**inux作为一种新兴的操作系统**，几乎支持所有的Unix下**常用的进程间通信方法：管道、消息队列、共享内存、信号量、套接口等等。**
  
      * **管道**：用于本机不同进程的通信，是指⽤于**连接⼀个读进程和⼀个写进程**，**以实现它们之间通信的共享⽂件**，⼜称 pipe ⽂件，**半双⼯的，具有固定的读端和写端**，写进程在管道的尾端写⼊数据，读进程在管道的⾸端读出数据。 
  
        * **匿名管道：用于父进程和子进程间的通信**
  
          * 对于父子进程的通信可以采用pipe()和fork函数实现
  
          * Int pipe(int fd[2]); 当⼀个管道建⽴时，会创建两个⽂件描述符，要关闭管道只需将这两个⽂件描述符关闭即可。  
  
          * ```c++
            #include <unistd.h> 
            int pipe(int filedis[2]);
            #define INPUT 0 
            #define OUTPUT 1 
            
            void main() {
                int file_descriptors[2];
                /*定义子进程号 */
                pid_t pid;
                char buf[256];
                int returned_count;
                /*创建无名管道*/
                pipe(file_descriptors);
                /*创建子进程*/
                if ((pid = fork()) == -1) {
                    printf("Error in fork/n");
                    exit(1);
                }
                /*执行子进程*/
                if (pid == 0) {
                    printf("in the spawned (child) process.../n");
                    /*子进程向父进程写数据，关闭管道的读端*/
                    close(file_descriptors[INPUT]);
                    write(file_descriptors[OUTPUT], "test data", strlen("test data"));
                    exit(0);
                }
                else {
                    /*执行父进程*/
                    printf("in the spawning (parent) process.../n");
                    /*父进程从管道读取子进程写的数据，关闭管道的写端*/
                    close(file_descriptors[OUTPUT]);
                    returned_count = read(file_descriptors[INPUT], buf, sizeof(buf));
                    printf("%d bytes of data received from spawned process: %s/n",
                        returned_count, buf);
                }
            }
            ```
  
        * 有名管道：可以**在⽆关的进程之间交换数据**  
  
          * 两种方式创建有名管道：命令行方式mknod系统调用和函数mkfifo
  
            * 方式一：mkfifo("myfifo","rw"); 
            * 方式二：mknod myfifo p
  
          * **生成了有名管道**后，就可以使用一般的**文件I/O函数**如open、close、read、write等来对它进行操作。
  
          * ```c++
            /* 进程一：读有名管道*/
            #include <stdio.h> 
            #include <unistd.h> 
            void main() {
                FILE * in_file;
                int count = 1;
                char buf[80];
                in_file = fopen("mypipe", "r");
                if (in_file == NULL) {
                    printf("Error in fdopen./n");
                    exit(1);
                }
                while ((count = fread(buf, 1, 80, in_file)) > 0)
                    printf("received from pipe: %s/n", buf);
                fclose(in_file);
            }
            　 /* 进程二：写有名管道*/
            #include <stdio.h> 
            #include <unistd.h> 
            void main() {
                FILE * out_file;
                int count = 1;
                char buf[80];
                out_file = fopen("mypipe", "w");
                if (out_file == NULL) {
                    printf("Error opening pipe.");
                    exit(1);
                }
                sprintf(buf, "this is test data for the named pipe example/n");
                fwrite(buf, 1, 80, out_file);
                fclose(out_file);
            }
            ```
  
      * **消息队列**
  
        * 用于运行于同一台机器上的进程间通信，它和管道很相似，事实上，它是一种**正逐渐被淘汰的通信方式**，我们可以用流管道或者套接口的方式来取代它，所以，我们对此方式也不再解释，也建议读者忽略这种方式。
        * 消息队列是**有消息的链表**，**存放在内核中**并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  
      * 共享内存
  
        * 进程可以**将同一段共享内存连接到它们自己的地址空间**，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，**所做的改动将立即影响到可以访问该共享内存的其他所有进程。**
  
        * 共享内存是**最快的⼀种进程通信⽅式**，因为进程是**直接对内存进⾏存取**；
  
        * 对**这块临界区的访问**需要通过**信号量来进行进程同步**。
  
        * **创建共享内存**：int shmget(key_t key, int size, int flag);
  
          成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。
  
          - key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。
          - size：共享内存容量。
          - flag：权限标志位，和open的mode参数一样。
  
        * **连接到共享内存地址空间**：void *shmat(int shmid, void *addr, int flag);
  
          返回值即共享内存实际地址。
  
          - shmid：shmget()返回的标识。
          - addr：决定以什么方式连接地址。
          - flag：访问模式。
  
        * **从共享内存分离**：int shmdt(const void *shmaddr);
  
          调用成功返回0，失败返回-1。
  
          - shmaddr：是shmat()返回的地址指针。
  
      * 信号量 https://www.cnblogs.com/tgycoder/p/5263644.html
  
        * 信号量是⼀个**计数器**，信号量⽤于**实现进程间的互斥与同步**，**用来记录对某个资源（如共享内存）的存取状况**  
  
        * 多线程同步的信号量是POSIX信号量，而**在进程里使用SYSTEM V信号量。**
  
        * 信号量基于操作系统的PV操作，程序对**信号量的操作都是原⼦操作**；
  
        * 相关接口
  
          - **创建信号量**：int semget(key_t key, int nsems, int semflag);
  
            创建成功返回信号量标识符，失败返回-1。
  
            - key：进程pid。
            - nsems：创建信号量的个数。
            - semflag：指定信号量读写权限。
  
          - **改变信号量值**：int semop(int semid, struct sembuf *sops, unsigned nsops);
  
            我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。
  
            struct sembuf结构体定义如下：
  
            ```c++
            struct sembuf{
                short sem_num;
                short sem_op;
                short sem_flg;
            };  
            ```
  
            成功返回信号量标识符，失败返回-1。
  
            - semid：信号量集标识符，由semget()函数返回。
            - sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。
            - nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。
  
          - **直接控制信号量信息**：int semctl(int semid, int semnum, int cmd, union semun arg);
  
            - semid：信号量集标识符。
            - semnum：信号量集数组上的下标，表示某一个信号量。
            - arg：union semun类型。
  
      * 信号
  
        * **通知接收进程有某种事情发生**，除了用于进程间通信外，进程还可以发送信号给进程本身
  
      * **套接字通信**
  
        * 套接口（socket）编程是**实现Linux系统和其他大多数操作系统中进程间通信的主要方式之一。**我们熟知的WWW服务、FTP服务、TELNET服务等都是基于套接口编程来实现的。除了**在异地的计算机进程间**以外，套接口**同样适用于本地同一台计算机内部的进程间通信。**
  
  * 多线程
  
    * 线程
  
      * **多线程之间既相互独立**(拥有自己的线程栈)，又相互影响(共享进程空间). 而因为这种影响导致了**对于同一资源不同的线程分别同时进行读和写造成的数据混乱问题**, 因此在多线程之中大量用到**互斥和同步技术**(下面有详细的讲解)
  
      * **每个进程都有一个主线程**，就是main函数，当主线程结束，进程也会结束, 进程空间释放了,其它线程也一起结束
  
      * Linux本身没有实现线程，在Linux中使用线程需要借助第三方线程库，在Linux使用多线程常使用pthread库，**使用pthread库时包含头文件 pthread.h,编译时要链接pthread库(-pthread),pthread库中的所有函数都以pthread_开头**
  
      * 线程创建：pthread_create
  
        * ```c++
          #include <pthread.h>
          /* Create a new thread, starting with execution of START-ROUTINE
             getting passed ARG.  Creation attributed come from ATTR.  The new
             handle is stored in *NEWTHREAD.  */
          extern int pthread_create (pthread_t *__restrict __newthread,
          			   const pthread_attr_t *__restrict __attr,
          			   void *(*__start_routine) (void *),
          			   void *__restrict __arg) __THROWNL __nonnull ((1, 3));
          参数:
                            __newthread - 传出参数，传出创建线程的ID，指针结构
                            attr - 线程属性(给NULL表示使用默认属性)
                            __start_routine - 线程函数(线程执行的代码)
                            arg - 线程函数的参数
                    成功返回0，失败返回错误码
          ```
  
        * 
  
      * **获取线程ID**：pthread_self
  
        * ```c++
          /* Obtain the identifier of the current thread.  */
          extern pthread_t pthread_self (void) __THROW __attribute__ ((__const__));
          ```
  
        * 
  
      * 等待线程结束：pthread_join / 线程分离---pthread_detach
  
        * phread_join：
  
          * ```c++
            /* Make calling thread wait for termination of the thread TH.  The
               exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
               is not NULL.
            
               This function is a cancellation point and therefore not marked with
               __THROW.  */
            extern int pthread_join (pthread_t __th, void **__thread_return);
                    参数:
                            thread - 要等待的线程ID
                            retval - (类型为void **), 是传出参数，传出结束线程的返回值
                    成功返回0，失败返回-1
            
            ```
  
          * 主线程阻塞等待线程结束，后续可对线程的资源进行回收，避免线程变成僵尸线程
  
        * pthread_detach：
  
          * ```c++
            /* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
               The resources of TH will therefore be freed immediately when it
               terminates, instead of waiting for another thread to perform PTHREAD_JOIN
               on it.  */
            extern int pthread_detach (pthread_t __th) __THROW;
            // 传入要设置的线程ID
            ```
  
          * 主要是将**线程属性更改为unjoinable**，便于资源的释放，详见PS linux线程有两种状态joinable状态和unjoinable状态。**分离状态的线程结束(退出)后自动回收资源**,不需要主线程通过pthread_join等待回收
  
      * 线程退出：
  
        * 正常退出：pthread_exit【自己退出】
  
          * ```c++
            /* Terminate calling thread.
            
               The registered cleanup handlers are called via exception handling
               so we cannot mark this function with __THROW.*/
            extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));
            // 参数就是线程函数的返回值
            ```
  
          * **正常退出有以下两种方式:**
  
            * 在线程函数中执行**return语句**(**不会执行退出处理函数**)
  
            * 调用了**pthread_exit函数**退出(可以**执行退出处理函数**, 这个函数可以由程序猿自己定义)
  
        * 非正常退出：pthread_cancel
  
          * **非正常退出有以下两种方式:**
  
            * 线程**执行时遇到错误(不会执行退出处理函数)**
            * **被其他线程终止/取消(pthread_cancel)(可以执行退出处理函数）**
  
          * ```c++
            /* Cancel THREAD immediately or at the next possibility.  */
            extern int pthread_cancel (pthread_t __th);
            // 参数就是要取消线程的ID，
            ```
  
          * 此外, 线程可以设置**是否允许被取消**【线程属性】
  
      * 线程**退出处理函数**：pthread_cleanup_push / pthread_cleanup_pop
  
        * 其中push函数用于往**线程退出处理函数栈**中 加入 **退出处理函数**，pop函数用于往线程退出处理函数栈中 取出 退出处理函数
  
        * push 和 pop 必须**成对出现,**否则编译报错
  
        * 退出处理函数在以下三种情况下会**自动执行** :
  
          * 线程**被其他线程取消(pthread_cancel)**,调用所有加入了的退出处理函数
  
          * 线程**调用pthread_exit自己退出**,调用所有加入了的退出处理函数
  
          * **执行pthread_cleanup_pop、同时传入非0参数时**, 在线程退出处理函数栈中遵循先进后出原则**取出一条退出处理函数,并执行它**
  
        * ```c++
          /* Install a cleanup handler: ROUTINE will be called with arguments ARG
             when the thread is canceled or calls pthread_exit.  ROUTINE will also
             be called with arguments ARG when the matching pthread_cleanup_pop
             is executed with non-zero EXECUTE argument.
          
             pthread_cleanup_push and pthread_cleanup_pop are macros and must always
             be used in matching pairs at the same nesting level of braces.  */
          #  define pthread_cleanup_push(routine, arg) \
            do {									      \
              __pthread_cleanup_class __clframe (routine, arg)
          
          /* Remove a cleanup handler installed by the matching pthread_cleanup_push.
             If EXECUTE is non-zero, the handler function is called. */
          #  define pthread_cleanup_pop(execute) \
              __clframe.__setdoit (execute);					      \
            } while (0)
          
              push:
                  routine - 退出处理函数
                  arg - 传递给退出处理函数的参数
              pop:
                  execute - 非0:取出执行
                                  0:取出不执行
          ```
  
        * 
  
      * 线程的属性：线程的属性**在创建线程可以给定**，线程**运行期间某些属性可以修改**
  
        * **初始化属性结构和销毁属性结构**，pthread_attr_init / pthread_attr_destroy
  
          * ```c++
            /* Initialize thread attribute *ATTR with default attributes
               (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
                no user-provided stack).  */
            // attr为传入参数 得到当前线程的属性
            extern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1));
            
            /* Destroy thread attribute *ATTR.  */
            // 销毁属性结构
            extern int pthread_attr_destroy (pthread_attr_t *__attr)
                 __THROW __nonnull ((1));
            ```
  
          * **使用属性前先调用init函数初始化**，**不再使用调用destroy函数销毁**
  
        * **属性设置和获取函数**，pthread_attr_setdetachstate / pthread_attr_getdetachstate
  
          * 设置线程的**分离/join属性**:
  
            * ```c++
              /* Get detach state attribute.  */
              extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
              					int *__detachstate)
                   __THROW __nonnull ((1, 2));
              
              /* Set detach state attribute.  */
              extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
              					int __detachstate)
                   __THROW __nonnull ((1));
                  参数:
                      attr - 属性
                      deatchstate - 状态
                          PTHREAD_CREATE_DETACHED - 分离状态
                          PTHREAD_CREATE_JOINABLE - join状态(默认)
              ```
  
          * 设置线程**是否允许被其他线程取消**:
  
            * ```c++
              /* Set cancelability state of current thread to STATE, returning old
                 state in *OLDSTATE if OLDSTATE is not NULL.  */
              extern int pthread_setcancelstate (int __state, int *__oldstate);
                  state(状态)：
                      PTHREAD_CANCEL_ENABLE - 允许取消(默认)
                      PTHREAD_CANCEL_DISABLE - 禁止取消
              ```
  
        * **多进程和多线程的接口比较**
  
          * ![img](../../img/v2-b257b1f3adecfac4136a11bb72137316_720w.webp)
  
    * **线程的互斥和同步**
  
      * 多线程之间共享所处进程的资源，因此很容易出现共享数据冲突。解决方案就是**将线程对共享资源的访问由并行改为串行**，实现**这种串行访问的技术**就是我们所谓**线程的互斥和同步技术**
  
        * 多线程中实现互斥和同步的技术包括：互斥锁 信号量 条件变量
  
          **其中互斥锁和信号量常用于互斥，条件变量用于同步**
  
      * **信号量**：信号量是一个**计数器**，用来**控制访问共享资源的最大并行 线程/进程 数**，工作原理和进程中的信号量集中的信号量是一样的, 但是它们是不一样的两个东西
  
        * 信号量**不属于线程库的范围，只是一个辅助工具**，使用信号量需要加头文件 **semaphore.h**
  
        * 信号量分为**无名信号量和有名信号量**，最常用是无名信号量
  
        * **无名信号量**：
  
          * **声明初始化信号量**
  
            * ```tex
              sem_t sem;
              sem_init(&sem,0,信号量初始值);
              第一参数是信号量的地址
              第二参数表示使用场景，0表示用于线程间共享，非0表示用进程间共享(无效)
              第三个参数就是信号量的初始值
              ```
  
          * **P操作(-1)**
  
            * sem_wait(&sem);
  
          * **执行访问共享资源代码**
  
          * **V操作(+1)**
  
            * sem_post(&sem);
  
          * **不再使用销毁信号量**
  
            * sem_destroy(&sem);
  
        * **有名信号量：**
  
          * **创建/打开有名信号量**
  
            * ```c++
              /* Open a named semaphore NAME with open flags OFLAG.  */
              extern sem_t *sem_open (const char *__name, int __oflag, ...) __THROW;
                  参数:
                      name - 有效的路径
                      oflag - 打开标志(同open的标志)
                   成功返回信号量的地址，失败返回SEM_FAILED
              ```
  
          * PV操作类似无名信号量
  
          * **不再使用删除信号量**
  
            * ```c++
              /* Remove named semaphore NAME. 传入的是有名信号量的路径 */
              extern int sem_unlink (const char *__name) __THROW;
              ```
  
      * **互斥锁**：属于pthread线程库里面的，加锁只能加1次
  
        * 一系列api：
  
          * ```c++
            #include <pthread.h>
            /* Initialize a mutex.  */
            extern int pthread_mutex_init (pthread_mutex_t *__mutex,
            			       const pthread_mutexattr_t *__mutexattr)
                 __THROW __nonnull ((1));
            
            /* Destroy a mutex.  */
            extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
                 __THROW __nonnull ((1));
            
            /* Try locking a mutex.  */
            extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
                 __THROWNL __nonnull ((1));
            
            /* Lock a mutex.  */
            extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
                 __THROWNL __nonnull ((1));
            
            #ifdef __USE_XOPEN2K
            /* Wait until lock becomes available, or specified time passes. */
            extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
            				    const struct timespec *__restrict
            				    __abstime) __THROWNL __nonnull ((1, 2));
            #endif
            
            /* Unlock a mutex.  */
            extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
                 __THROWNL __nonnull ((1));
            ```
  
          * 
  
        * **声明初始化互斥锁**
  
          * ```text
                pthread_mutex_t lock;
                pthread_mutex_init(&lock,NULL);
            or
                pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
            ```
  
        * **加锁/上锁 --------- 访问共享资源前**
  
          * ```tex
                pthread_mutex_lock(&lock); ---------- 阻塞加锁(等待直到加锁成功)
                pthread_mutex_trylock(&lock);------- 非阻塞加锁(不管是否加锁成功都立即返回，成功返回0，失败返回非0)
            ```
  
        * 执行访问共享资源的代码
  
        * **解锁 ------------- 访问完共享资源**
  
          * ```tex
               pthread_mutex_unlock(&lock);
            ```
  
        * 不再使用**释放锁**
  
          * ```text
             pthread_mutex_destroy(&lock);
            ```
  
      * **条件变量**：在多线程程序运行中，某个线程需要**等待某个条件成立后再继续运行**，这种等待可以在其他线程中唤醒，**条件变量的使用需要互斥锁的支持**，用于**防止条件竞争,**这里**被竞争的是条件变量**。用于在线程之间**同步共享数据**的值。
  
        * **分配初始化**
  
          * ```c++
                pthread_cont_t cond;
                pthread_cond_init(&cond,NULL);
            // func
            /* Initialize condition variable COND using attributes ATTR, or use
               the default values if later is NULL.  */
            extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
            			      const pthread_condattr_t *__restrict __cond_attr)
                 __THROW __nonnull ((1));
            ```
  
        * **等待条件成立**
  
          * 函数声明：
  
            * ```c++
              /* Wait for condition variable COND to be signaled or broadcast.
                 MUTEX is assumed to be locked before.
              
                 This function is a cancellation point and therefore not marked with
                 __THROW.  */
              extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
              			      pthread_mutex_t *__restrict __mutex)
                   __nonnull ((1, 2));
              
              /* Wait for condition variable COND to be signaled or broadcast until
                 ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
                 absolute time specification; zero is the beginning of the epoch
                 (00:00:00 GMT, January 1, 1970).
              
                 This function is a cancellation point and therefore not marked with
                 __THROW.  */
              extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
              				   pthread_mutex_t *__restrict __mutex,
              				   const struct timespec *__restrict __abstime)
                   __nonnull ((1, 2, 3));
              ```
  
          * **代码如何写,格式如下(**其中互斥锁的作用是防止条件竞争**):**
  
            * ```c++
                 //先加锁
                  pthread_cond_wait(&cond,&lock);
                  //执行使用条件的代码
                  //解锁
              ```
  
        * **唤醒等待条件的线程**
  
          * 函数声明：
  
            * ```c++
              /* Wake up one thread waiting for condition variable COND.  */
              extern int pthread_cond_signal (pthread_cond_t *__cond)
                   __THROWNL __nonnull ((1));
              
              /* Wake up all threads waiting for condition variables COND.  */
              extern int pthread_cond_broadcast (pthread_cond_t *__cond)
                   __THROWNL __nonnull ((1));
              ```
  
          * 使用：
  
            * ```c++
                  pthread_cond_signal(&cond); ------------ 唤醒一个等待条件的线程
                  pthread_cond_broadcast(&cond); --------- 唤醒所有等待的线程(惊群)
              ```
  
        * **不再使用可以删除**
  
          * ```c++
            // function declare:
            /* Destroy condition variable COND.  */
            extern int pthread_cond_destroy (pthread_cond_t *__cond)
                 __THROW __nonnull ((1));
             
            pthread_cond_destroy(&cond);
            ```
  
        * 条件变量和互斥锁配合的原因：
  
          * 条件变量用于**某个线程需要在某种条件成立时才去保护它将要操作的临界区**，这种情况从而**避免了线程不断轮询检查该条件是否成立而降低效率**的情况，这是实现了效率提高。。。在条件满足时【唤醒操作】，**自动退出阻塞，再加锁进行操作。**
  
  * 网络编程
  
    * 五大IO模型：同步|异步、阻塞、非阻塞、IO复用、信号驱动
  
      * IO：**涉及计算机核心与其他设备间数据迁移的过程，就是IO**。
  
        * 真正的IO是在**操作系统**执行的。即应用程序的IO操作分为两种动作：**IO调用和IO执行**。IO调用是由进程（应用程序的运行态）发起，而IO执行是**操作系统内核**的工作。此时所说的**IO是应用程序对操作系统IO功能的一次触发，即IO调用。**
  
        * IO调用：应用程序进程向操作系统**内核**发起调用。
  
        * IO执行：操作系统内核完成IO操作。
  
          * **准备数据阶段**：内核等待I/O设备准备好数据
  
          * **拷贝数据阶段**：将数据**从内核缓冲区拷贝到用户空间缓冲区**
  
            ![img](../../img/v2-2e58f76c1e78e7926e946f6043003b42_720w.webp)
  
      * **阻塞IO**：进程发起**IO调用**，但是如果**内核的数据还没准备好**的话，那应用程序进程就一直在**阻塞等待**，一直等到内核数据准备好了，**从内核拷贝到用户空间，才返回成功提示**![img](../../img/v2-e1dcacd5321db52b77b7971fbad8b940_720w.webp)
  
        * 经典阻塞IO：**阻塞socket、Java BIO**。
        * 缺点：如果内核数据一直没准备好，那用户进程**将一直阻塞**，**浪费性能**，可以使用**非阻塞IO**优化。
  
      * **非阻塞IO**：如果内核数据还没准备好，**可以先返回错误信息给用户进程，让它不需要等待**，而是通过**轮询的方式再来请求**
  
        ![img](../../img/v2-99132af46228a4924ff41a46a8206636_720w.webp)
  
        * 流程：
          * 应用进程向操作系统内核，发起`recvfrom`读取数据。
          * 操作系统内核数据没有准备好，立即返回`EWOULDBLOCK`错误码。
          * 应用程序**轮询调用，继续向操作系统内核发起`recvfrom`读取数据**。
          * 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。
          * 完成调用，返回成功提示。
        * 缺点：非阻塞IO模型，简称**NIO**，`Non-Blocking IO`。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在**性能问题**，即**频繁的轮询**，导致**频繁的系统调用**，同样会消**耗大量的CPU资源。**可以考虑**IO复用模型**，去解决这个问题。
        * 每个线程只能处理一个连接，服务器资源浪费，**可由一个线程完成数据状态询问的操作**，当有数据准备就绪之后**再分配对应的线程去读取数据**，这么做就可以**节省出大量的线程资源出来，这个就是IO复用模型的思路。**
  
      * **IO多路复用**【**单个线程/进程监听多个文件描述符**，一旦某个fd就绪，就可以进行相应的读写操作。通过减少运行的进程，有效的减少**上下文切换**的消耗。】
  
        * 思路：系统给我们提供**一类函数**（如我们耳濡目染的**select、poll、epoll**函数）【这些函数本身是**阻塞的**。但是和阻塞IO所不同的是这些函数可以**同时阻塞多个IO操作**。其所**监听的`socket`设置为`non-blocking`。**】，它们可以**同时监控多个`fd`的操作**，一旦有**事件触发**，才**真正的调用IO操作函数**，进行相应处理。
        * **多路复用 API 返回的事件并不一定可读写的**，如果使用**阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞**，**因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况**
        * 总结：
          * 需要两次系统调用【select和recvfrom】，而blocking IO只调用了一个system call (recvfrom)。但是，**用select的优势在于它可以同时处理多个connection**。
          * 如果**处理的连接数不是很高**的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。前者**需要两个系统调用**(select/epoll + read)，而**后者只有一个(read)**。但是**在连接数很多**的情况下，select/epoll的优势就凸显出来了。**select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。**
        * select：
          * 通过调用select函数，可以同时监控多个`fd`，在`select`函数监控的`fd`中，**只要有任何一个数据状态准备就绪了，`select`函数就会返回可读状态**，这时应用进程再发起`recvfrom`请求去读取数据。![img](../../img/v2-9e7e0c1565e7d1f10062759f8241e4b5_720w.webp)
          * 缺点：
            * 监听的**IO最大连接数有限**，在Linux系统上一般为1024。
            * select函数返回后，**是通过遍历`fdset`，找到就绪的描述符`fd`**。（仅知道有I/O事件发生，却不知是哪几个流，所以遍历所有流）
          * 实现方式：
            * 将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。
            * **2 次「遍历」文件描述符集合**，一次是在内核态里，一个次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
            * select 使用**固定长度的 BitsMap，表示文件描述符集合**，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，**由内核中的 FD_SETSIZE 限制**， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。
            * poll 不再用 BitsMap 来存储所关注的文件描述符，**取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制**，当然还会受到系统文件描述符限制。
            * **都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着**并发数上来，性能的损耗会呈指数级增长。**
        * poll：
          * 因为**存在连接数限制**，所以后来又提出了**poll**。与select相比，**poll**解决了**连接数限制问题**。
          * select和poll一样，还是需要通过**遍历文件描述符**来获取已经就绪的`socket`。如果同时连接的大量客户端**在一时刻可能只有极少处于就绪状态**，伴随着监视的描述符数量的增长，**效率也会线性下降**。
        * epoll：
          * 为了解决`select/poll`存在的问题，多路复用模型`epoll`诞生，它采用**事件驱动来实现**，流程图如下：![img](../../img/v2-b49fad15c6c66c1dd3c3493716113037_720w.webp)
          * **epoll**先通过`epoll_ctl()`来**注册一个`fd`（文件描述符）**，一旦基于某个`fd`就绪时，内核会**采用回调机制，迅速激活这个`fd`，当进程调用`epoll_wait()`时便得到通知。**这里去掉了**遍历文件描述符**的坑爹操作，而是采用**监听事件回调**的的机制。这就是epoll的亮点。
          * 使用方式:
          
            * ```c++
              // 先用e poll_create 创建一个 epoll对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。
              int s = socket(AF_INET, SOCK_STREAM, 0);
              bind(s, ...);
              listen(s, ...)
              
              int epfd = epoll_create(...);
              epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中
              
              while(1) {
                  int n = epoll_wait(...);
                  for(接收到数据的socket){
                      //处理
                  }
              }
              ```
          * epoll 通过两个方面，很好解决了 select/poll 的问题。https://cloud.tencent.com/developer/article/1805838
          
            * epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket **通过 `epoll_ctl()` 函数加入内核中的红黑树里**
              * epoll 因为在内核维护了红黑树，**可以保存所有待检测的 socket** ，所以只需要传入一个待检测的 socket，**减少了内核和用户空间大量的数据拷贝和内存分配。**
            * epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件【epoll_create创建内核事件表】**，我们可以操作向该内核事件表加入监听的事件【**epoll_ctl操作内核事件表**】，当某个 socket 有事件发生时，内核通过**回调函数**会将其**加入到这个就绪事件列表中**，当用户调用 `epoll_wait()` 函数时，**返回有事件发生的文件描述符的个数和已就绪事件集合**，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。【**epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用 `mmap()` 文件映射让内核和用户空间，共享同一块内存实现消息传递，减少了不必要的拷贝。**】![img](../../img/epoll.png)
          * **边缘触发和水平触发**：**select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。**
          
            * **边缘触发（*edge-triggered，ET*）**
              * 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序**要保证一次性将内核缓冲区的数据读取完；**
              * 基于ET的读写流程：
                * I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以**在收到通知后应尽可能地读写数据**，以免错失读写的机会。
                * 会**循环**从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，**进程会阻塞在读写函数那里，程序就没办法继续往下执行**。所以，**边缘触发模式一般和非阻塞 I/O 搭配使用**，程序会**一直执行 I/O 操作**，直到**系统调用（如 `read` 和 `write`）返回错误**，**错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。**
              * **边缘触发的效率比水平触发的效率要高**，因为**边缘触发可以减少 epoll_wait 的系统调用次数，**系统调用也是有一定的开销的的，毕竟也存在**上下文的切换**。
            * **水平触发（*level-triggered，LT*）**
              * 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；【确保事件被处理才不会触发】
          * 总结：https://cloud.tencent.com/developer/article/1805838
          
            * **epoll**明显优化了IO的执行效率，但在进程调用`epoll_wait()`时，仍然可能被阻塞的。
            * 优化：不用我老是去问你数据是否准备就绪，等我发出请求后，你**数据准备好了通知我**就行了，这就诞生了**信号驱动IO模型**。![img](../../img/8l80fsuy5y.png)
    
      * **信号驱动**
    
        * 信号驱动IO**不再用主动询问的方式去确认**数据是否就绪，而是**向内核发送一个信号**（调用`sigaction`的时候建立一个`SIGIO`的信号），然后**应用用户进程可以去做别的事，不用阻塞。**
        * 当内核数据准备好后，**再通过`SIGIO`信号通知应用进程，数据准备好后的可读状态。**
        * 应用用户进程收到信号之后，立即调用`recvfrom`，去读取数据。![img](../../img/v2-300183981fa735fd3226ac24812f827e_720w.webp)
        * 总结：
          * 信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。
            * 基于**消息通知机制**，避免了用户进程主动询问网络数据是否已拷贝到内核缓冲，数据准备好时，内核传递相应信号【消息通知】，用户绑定的**信号处理函数**进行数据处理
          * 缺点：
            * **数据复制到应用缓冲的时候**，应用进程**还是阻塞的。**不管是BIO，还是NIO，还是信号驱动，**在数据从内核复制到应用缓冲的时候**，**都是阻塞的。**AIO【真正异步IO】可以解决该问题。
    
      * **异步**
    
        * `AIO`实现了**IO全流程的非阻塞**，就是应用进程发出系统调用后，是立即返回的，但是**立即返回的不是处理结果，而是表示提交成功类似的意思**。
        * **等内核数据准备好，将数据拷贝到用户进程缓冲区**，发送**信号通知用户进程IO操作执行完毕**
        * ![img](../../img/v2-4c9f6d5f7d5e969bd6dddbad8d5ec77d_720w.webp)
        * 异步IO的优化思路很简单，**只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。**
          * Linux中提供了异步IO的接口`aio_read`和`aio_write`，`aio_read`会给内核传递**文件描述符**，**缓冲区指针**，**缓冲区大小**，**文件偏移**等；当数据准备好，内核直接将数据`copy`到用户空间，**`copy`完后给用户进程发送一个信号，进行用户数据异步处理**（`aio_read`）【需要和信号处理函数结合使用】
    
      * **阻塞、非阻塞、同步、异步IO划分**
    
        * ![img](../../img/v2-7f72e29cf18c31737e619865e5f8c08e_720w.webp)
    
    * 高性能网络模式：Reactor和Procator
    
      * Reactor：**基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。**【Redis、Netty、Nginx、Memcache】
        * 特性：**对事件反应**，也就是**来了一个事件，Reactor 就有相对应的反应/响应**。【 **I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程**】**主线程只负责监听IO，获取io请求后把请求对象放入请求队列，交给工作线程，工作线程负责数据读取以及逻辑处理。**
    
        * 组成：Reactor 模式主要由 **Reactor 和处理资源池**这两个核心部分组成
          * Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；
    
          * 处理资源池负责处理事件，如 read -> 业务逻辑 -> send；
    
        * Reactor常见方案：**非阻塞同步网络模式**
          * 单 Reactor 单进程 / 线程：
            * ![img](../../img/单Reactor单进程.png)
    
            * 各对象作用：
              * Reactor 对象的作用是监听和分发事件；
    
              * Acceptor 对象的作用是获取连接；
              * Handler 对象的作用是处理业务；
    
            * 大致实现流程：
              * Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；
    
              * 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；
              * 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；
              * Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。
    
            * 总结：
              * 单 Reactor 单进程的方案因为**全部工作都在同一个进程内完成**，所以实现起来比较简单，**不需要考虑进程间通信，也不用担心多进程竞争。**
    
              * 缺点：
                * 因为只有一个进程，**无法充分利用 多核 CPU 的性能**；
    
                * Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，**如果业务处理耗时比较长，那么就造成响应的延迟**；
    
              * **不适用计算机密集型的场景，只适用于业务处理非常快速的场景**。
                * Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，**因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上**，所以 Redis 对于命令的处理是单进程的方案。
    
          * 单 Reactor 多线程 / 进程；
            * ![img](../../img/单Reactor多线程.png)
            * 大致实现流程：【web服务器中子线程也包括了处理读和写】
              * Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；
              * 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；
              * 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；
              * Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；
              * 子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；
            * 总结：
              * 优势在于**能够充分利用多核 CPU 的能**，那既然引入多线程，那么自然就带来了**多线程竞争资源的问题**。
              * 要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要**在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源**，**待该线程操作完释放互斥锁后**，其他线程才有机会操作共享数据。
              * 单Reactor 多进程：
                * 单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要**考虑子进程 <-> 父进程的双向通信**，并且父进程还得知道子进程要将数据发送给哪个客户端。
                * 多线程间可以共享数据，虽然要**额外考虑并发问题**，但是**这远比进程间通信的复杂度低得多**，因此实际应用中也**看不到单Reactor 多进程的模式。**
              * 缺陷：
                * **因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方**。
          * 多 Reactor 多进程 / 线程；
            * ![img](../../img/主从Reactor多线程.png)
            * 大致实现流程：
              * 主线程中的 MainReactor 对象**通过 select 监控连接建立事件**，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；
              * 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select **继续进行监听**，并创建一个 Handler 用于处理连接的响应事件。
              * 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。
              * Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。
              * 主线程和子线程分工明确，**主线程只负责接收新连接，子线程负责完成后续的业务处理。**
              * 主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。
            * 总结：
              * 大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。
              * 采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。
                * 具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现**惊群现象**），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。
    
        * **Proactor**：**异步网络模式**
          * ![img](../../img/Proactor.png)
    
          * 大致实现流程：**proactor模式将所有IO读写操作 都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。**
            * Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；
    
            * Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作；
            * Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor；
            * Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；
            * Handler 完成业务处理；
    
          * 总结：
            * 在 Linux 下的异步 I/O 是不完善的， **`aio` 系列函数是由 POSIX 定义的异步操作接口**，不是真正的操作系统级别支持的，而是**在用户空间模拟出来的异步**，并且仅仅支持**基于本地文件的 aio 异步操作**，**网络编程中的 socket 是不支持的**，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。
    
            * 而 Windows 里实现了**一套完整的支持 socket 的异步编程接口**，这套接口就是 `IOCP`，是**由操作系统级别实现的异步 I/O**，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。
        * Reactor与Proactor的对比：
          * **Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件**。
            * 在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。
    
          * **Proactor 是异步网络模式， 感知的是已完成的读写事件**。
            * 在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。
    
          * 因此，**Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」**，而 **Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」**。这里的「事件」就是有**新连接、有数据可读、有数据可写**的这些 I/O 事件这里的「处理」包含**从驱动读取到内核以及从内核读取到用户空间**。
    

### linux socket编程流程

* **包含头文件**：首先，在程序中包含Socket编程相关的头文件，如`<sys/socket.h>`、`<netinet/in.h>`等。
* **创建Socket**：使用`socket()`系统调用创建一个Socket，并指定Socket的类型（如TCP或UDP）以及协议族（如IPv4或IPv6）。
* **绑定地址**：如果是**服务器程序，需要使用`bind()`系统调用将Socket绑定到一个地址上**，以便**客户端可以连接到这个地址。**
* **监听连接**（仅适用于服务器）：如果是服务器程序，使用`listen()`系统调用开始**监听来自客户端的连接请求**。
* **接受连接**（仅适用于服务器）：使用`accept()`系统调用**接受客户端的连接请求**，返回**一个新的Socket用于与客户端通信。**
* **连接到服务器**（仅适用于客户端）：如果是客户端程序，**使用`connect()`系统调用连接到服务器。**
* **收发数据**：使用`send()`和`recv()`系统调用**发送和接收数据**。对于UDP Socket，可以使用`sendto()`和`recvfrom()`。
* **关闭Socket**：使用`close()`系统调用关闭Socket。



## Mysql

* 事务隔离级别实现：
  * 读已提交：事务每次读数据时都会重新创建ReadView
  * 可重复读：事务开始时创建ReadView
  * MVCC：使用ReadView和undo log形成的不同版本的记录链来判断哪个版本记录对于当前事务是可见的。**通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为**【快照读，普通select语句】
    * select for update、update、insert、delete 都是**当前读**，会加**互斥锁**，事务提交完后锁才会释放
    * select ... lock in share mode; 加共享锁
* 幻读解决：
  * 可重复读隔离级别下：
    * 针对快照读，通过MVCC很大程度避免了幻读的发生，但是**MVCC并不能完全解决幻读现象。**
    * 针对当前读，通过 **next-key lock（记录锁+间隙锁）**方式**解决了幻读。**
      * 【**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**】
      * 【**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。】
* 锁：
  * **加锁的对象是索引**【如果需要回表的话还需对主键索引加锁】，**加锁的基本单位是next-key lock**【会退化成记录锁或间隙锁】
  * Innodb在扫描记录的时候，都是针对索引项这个单位去加锁的，**不带索引条件的一般是全表扫描**，也就是表里的主键索引项都加锁
  * 行级锁
    * 记录锁
    * 间隙锁
    * 临键锁
  * 表级锁
    * 意向锁
    * 自增锁：特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。

* 日志：
  * **事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务**，**事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务**
  * undo log
    * **实现事务回滚、保障事务的原子性。**
    * **实现 MVCC（多版本并发控制）关键因素之一**。
    * 同样通过redo log保证持久化
  * redo log
    * **保证了事务四大特性中的持久性**。
    * **将写操作从「随机写」变成了「顺序写」**，提升 MySQL 写入磁盘的性能。
      * redo log 也有自己的缓存—— **redo log buffer**，每当产生一条 redo log 时，会**先写入到 redo log buffer**，后续在持久化到磁盘
      * redo log buffer 默认在事务提交时刷回磁盘
    * 重做日志文件组是以**循环写**的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。
  * buffer pool
    * 内部为若干个缓存页，大小为16KB
    * 缓存**「索引页」和「数据页」**，还包括了 **Undo 页**，插入缓存、自适应哈希索引、锁信息等等。
    * 会在适当的时候，由**后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里**
  * bin log
    * binlog 文件是记录了**所有数据库表结构变更和表数据修改的日志**
    * Server 层实现的日志，所有存储引擎都可以使用； Server 层实现的日志，所有存储引擎都可以使用；
    * **用于备份恢复、主从复制；**
      * 主从复制过程梳理成 3 个阶段：
        - **写入 Binlog**：主库写 binlog 日志，提交事务，并更新本地存储数据。
        - **同步 Binlog**：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
        - **回放 Binlog**：回放 binlog，并更新存储引擎中的数据。
      * 主从复制还有哪些模型
        * **同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。**
        * **异步复制**（默认模型）
        * **半同步复制**
    * **一条更新语句执行完成后，然后开始记录该语句对应的 binlog**，**此时记录的 binlog 会被保存到 binlog cache**，并没有刷新到硬盘上的 binlog 文件，**在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。**
  * 两阶段提交
    * 在**持久化** redo log 和 binlog 这两份日志的时候，**MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决**。【避免造成主从环境的数据不一致性，**redo log 影响主库的数据，binlog 影响从库的数据**，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。】
    * 事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：
      - **prepare 阶段**：将 redo log **对应的事务状态设置为 prepare**，然后将 redo log 刷新到硬盘；
      - **commit 阶段**：将 binlog 刷新到磁盘，**接着调用引擎的提交事务接口**，将 redo log 状态设置为 commit（**将事务设置为 commit 状态后，刷入到磁盘 redo log 文件**）；



## 常用库

* 





## windows命令：

**网络配置相关**

```bash
# 本机监听2222端口收到的流量转发到172.25.170.170:2222
netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=172.25.170.170 connectport=2222
# 查看网络代理
netsh interface portproxy show all
# 设置防火墙规则 入流量 本地监听端口2222
netsh advfirewall firewall add rule name=WSL2 dir=in action=allow protocol=TCP localport=2222
```

