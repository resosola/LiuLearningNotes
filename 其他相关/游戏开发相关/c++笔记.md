* 指针数组和数组指针

  * 不论指针变量的类型是什么，在同一个平台下大小都一样。在 32 位操作系统中占 4 个字节，在 64 位操作系统中占 8 个字节。

  * **指针数组**实质是一个数组，**数组内元素全部是指针变量**； **数组指针**实质是一个指针，该**指针指向一个数组**; 
        区分两者，若**核心和星号\*结合**,表示核心是**指针**如int **(\*n)**[10]，指向int [10]，表示数组指针。
        若**核心和中括号[]结合**，表示核心是**数组**,如 int ***p[10****]**，内部元素为int \*，表示指针数组
        若核心和小括号结合，表示核心是函数，如int **q()**；
        遇到操作符优先级问题，看优先级高低,其中（）、[ ]、->优先级高于\*

    * **指针+1所得结果要根据指针类型加上一定的值**，不同类型的指针+1之后增加的大小不同，a是长度为5的int数组指针，所以要加5*sizeof(int)

      ```c++
      int main(void) {
           int a[5] = {1, 2, 3, 4, 5};
          // &a 类型为int[5] * 即指向长度为5的数组
          // (int *) 转为指向int类型的指针
           int *ptr = (int *)(&a + 1);
          // *(a + i) == a[i];
           printf("%d %d", *(a + 1), *(ptr - 1));
           return 0;
       }
      ```

      

  * 字符常量

    * 一种是**普通字符**，即用单撇号括起来的一个字符，如'b' ，'y'，‘？’。字符常量在储存在计算机的储存单元中时，是以其代码（一般采用**ASCII代码）储存**的。

    * 另一种是**转义字符**，即特殊字符常量。转移字符是C语言中表示字符的一种特殊形式，其含义是**将反斜杠后面的字符转换成另外的意义。**

    * 另外还可以**用字符的[ASCII](https://baike.baidu.com/item/ASCII)码表示，即用反斜符(\\)开头，后跟字符的ASCII码**，这种方法也称为**转义序列表示法**，具体方法是:有两种形式：

      * 一种是用字符的[八进制](https://baike.baidu.com/item/八进制)ASCII码，表示为：\0dd.这里，0dd是八进制值（0表示八进制可以省略）。

      * 另一种使用字符的[十六进制](https://baike.baidu.com/item/十六进制)ASCII码值，表示为　\xhh或Xhh　这里hh是两位十六进制值（x表示十六进制可以省略）。

        ![image-20220804102858418](info/LiuLearningNotes/img/image-20220804102858418.png)

        如：'A' ，'\101' 和 '\x41'都表示同一个[字符](https://baike.baidu.com/item/字符)常量。

  * 虚函数

    * 虚函数的执行依赖于虚函数表。而**虚函数表在构造函数中进行初始化工作**，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行，故构造函数不能声明为虚函数。
    * 虚函数行为是在**运行期间确定实际类型**的。

  * 重写和重载

    * **这两个都是多态的一种表现形式。**

      **重载：**

        **1、 重载是在编译器通过方法中形参的静态类型确定调用方法版本的过程。**

        **2、 重载是多态在编译期的表现形式**

        **3、 重载的判定只有两个条件（其他的条件都不能作为判定）：**

      ​      **1、 方法名一致**

      ​      **2、形参列表不同**

      **重写：**

        **1、重写在方法运行时，通过调用者的实际类型来确定调用的方法版本。（具体细说，就是子父类中的重写方法在对应的class文件常量池的位置相同，一旦子类没有重写，那么子类的实例就会沿着这个位置往上找，直到找到父类的同名方法****）**

        **2、重写只发生在可见的实例方法中：**

      ​      **1、静态方法不存在重写，形式上的重写只能说是隐藏。**

      ​      **2、私有方法也不存在重写，父类中private的方法，子类中就算定义了，就是相当于一个新的方法。**

      ​      **3、静态方法和实例方法不存在相互重写。**

        **3、重写满足一个规则：两同两小一大**

      ​      **1、两同：方法名和形参列表一致**

      ​      **2、两小：重写方法的返回值（引用类型）和抛出异常，要和被重写方法的返回值（引用类型）和抛出异常****相同或者是其子类。注意，一旦返回值是基本数据类型，那么重写方法和被重写方法必须相同，且不存在自动拆装箱的问题。**

      ​      **3、一大：重写方法的访问修饰符大于等于被重写方法的访问修饰符。**

  * struct

    * struct成员类型不可以是它自己。
      * 因为会递归定义。
        理论上这样**导致结构体的大小不能被计算**（无限大小）。所以不能在结构体里的成员类型是结构体本身。
        但是成员可以定义为该结构体的指针或引用。因为**指针的大小是已知的**（随编译器和操作系统而定）。
        所以可以定义**为该结构体的指针**，但不是该结构体。

  * 预编译指令

    * 带#的肯定是预编译指令了

    * Objective-C：#import
      C，C++：#include
      \#import由gcc编译器支持
      在 Objective-C 中，**#import 被当成 #include 指令的改良版本来使用**。除此之外，#import 确定一个文件只能被导入一次，这使你在递归包含中不会出现问题。
      使用哪一个还是由你来决定。一般来说，在导入 Objective-C 头文件的时候使用 #import，包含 C 头文件时使用 #include。

      **\#import比起#include的好处就是不会引起交叉编译**

    * \#define 宏定义是**直接替换**

  * 操作符

    * new和delete属于运算符。sizeof属于操作符，其求的是实际存储空间

  * 基本数据类型

    * 浮点数存在**精度问题**，不要用对浮点数进行等于和不等于的判断，那样得不到正确结果

  * 逗号表达式

    * 表达式1，表达式2，表达式3，...... ，表达式n

      逗号表达式的要领：

      (1) 逗号表达式的运算过程为：从左往右逐个计算表达式。

      (2) 逗号表达式作为一个整体，它的值为最后一个表达式（也即表达式n）的值。

      (3) 逗号[运算符](https://baike.baidu.com/item/运算符)的优先级别在所有运算符中最低。

      即int a=(3,2,1,0);赋值后a=0

  * 初始化

    * 对于用户定义类型：[类类型的数据成员对象**在进入函数体时已经构造完成**]
      1）如果使用类初始化列表，**直接调用对应的构造函数即完成初始化**
      2）如果在构造函数中初始化，那么**首先调用默认的构造函数，然后调用指定的构造函数**

      所以对于用户定义类型，使用列表初始化可以**减少一次默认构造函数调用过程**

  * static

  * 常见函数

    * void ***memcpy**( void *to, const void *from, size_t count )：

      功能：函数从from中复制count 个字符到to中，并返回to指针。 如果to 和 from 重叠，则函数行为不确定。

    * void ***memmove**( void *to, const void *from, size_t count )：

      功能：与mencpy相同，不同的是当to 和 from 重叠，函数正常仍能工作。

    * void ***memset**( void *buffer, int ch, size_t count )：

      功能： 函数拷贝ch 到buffer 从头开始的count 个字符里, 并返回buffer指针。 memset() 可以应用在将一段内存初始化为某个值。

    * char ***strcpy**( char *to, const char *from )：

      功能：复制字符串from 中的字符到字符串to，包括空值结束符。返回值为指针to。

    * char*  strcat(char *dest,char *src);

      功能：将src开始的字符串添加到dest字符串的末尾(覆盖dest的\0")

      strlen求的是字符串的有效位长度

    * ForwardIterator unique (ForwardIterator first, ForwardIterator last);
      
      功能：“去除”容器或者[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)中相邻元素的重复出现的元素
      
      (1) 这里的去除并非真正意义的erase，而是**将重复的元素放到容器的末尾，返回值是去重之后的尾地址。** 
      (2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数
      
    * void sort (RandomAccessIterator first, RandomAccessIterator last);
      
      功能：对数组，vector，deque一定范围进行快排，对应重载函数可以自定义排序规则。
      
    * iterator erase (const_iterator first, const_iterator last);
      
      功能：将容器中[first，last)范围内的元素删除，并返回last。
      
      

